{"title":"Transformations with Tidyverse","markdown":{"yaml":{"title":"Transformations with Tidyverse"},"headingText":"Slicing and filtering","containsRefs":false,"markdown":"\n\nDataset: https://archive.ics.uci.edu/ml/datasets/Adult\n\n```{r}\n#install.packages('tidyverse')\nlibrary(tidyverse)\n```\n\nTidy data is one observation per row, one measurement or variable per column and one value per cell.\n\n```{r}\nheader <- c(\"age\", \"workclass\", \"fnlwgt\",\"education\",\n\"education_num\", \"marital_status\", \"occupation\",\n\"relationship\", \"race\", \"sex\", \"capital_gain\", \"capital_loss\",\"hours_per_week\", \"native_country\", \"target\")\n\ndf <- read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", col_names = header, \n                   trim_ws = TRUE)\n\nhead(df)\n```\n\n\nThe basic form of dplyr for slicing it to use a `.` to consider everything from the object that precedes it. The returned object will be a tibble.\n\n```{r}\ndf %>% .[1:4, c(2:5)]\n```\n\n-   `slice_min(), slice_max()`: to fetch the top or bottom observation given a percentage.\n-   `slice_sample()`: to extract a sample.\n\n```{r}\ndf %>% slice_min(age, prop = 0.15)\n```\n```{r}\ndf %>% slice_sample(n=10, replace = FALSE) %>% .[,1:4]\n```\n\n## Filtering\n\n-   `filter()`: returns rows given a condition.\n-   `select()`: to choose variable to show in the given order.\n\n```{r}\ndf %>%\n  filter( age < 30 ) %>%\n  select( marital_status, age, education ) %>%\n  slice_sample( n = 10)\n```\n\n- distinct(): to extract unique values.\n\n```{r}\ndf %>% distinct(sex) \n```\n\n# Grouping and summarizing data\n\nThe next functions are complementary, usually used together.\n\n-   `group_by()`: to group a variable by its values\n-   `summarize()`: given a function with a variable returns the result.\n-   `ungroup()`: after `group_by()` with more than one variable, it returns a `tbl_df`. The ungrouped tibble requires less memory space than the tibble one.\n\n```{r}\ndf %>% group_by(workclass) %>% .[1:10,1:4]\n```\n```{r}\ndf %>% group_by(sex) %>% summarise( avg_age = mean(age), sd_age = sd(age))\n```\n```{r}\nmarital.groups <- df %>% group_by(marital_status, sex) %>%\n  summarize( avg_age = mean(age) )\nmarital.groups\n```\n```{r}\nungroup(marital.groups)\n```\n\n-   `quantile()`: returns the number corresponding the passing percentage.\n-   `first()`: returns the first number. Combined with `group_by()` returns the first number of each group.\n-   `across()`: applies a function to the selected columns.\n\n```{r}\ndf %>% group_by(marital_status) %>% summarise(first(age))\n```\n```{r}\ndf %>% group_by(sex) %>% summarise( \"50%\" = quantile(age, 0.5))\n```\n```{r}\ndf %>% select(1,3,5,11,12,13) %>%\n  summarise( across(everything(), mean) )\n```\n\n# Replacing and Filling Data\n\nA dataset will be imperfect, in this case we have '?' instead of NA. First, the character '?' has to be replaced with NA and then we can replace NA with other character.\n\n```{r}\nfor (var in colnames(df) ) {\n    print(\n        paste (var, nrow( df[df[var] == '?', ] ) )\n    )\n}\n```\n\nIn the output we can see the missing values represented with '?': \"workclass 1836\", \"occupation 1843\", and \"native_country 583\". Now we can use `mutate()` to edit the columns affected.\n\n```{r}\ndf.rep <- df %>%\n    mutate (workclass = replace(workclass, workclass == '?', NA),\n            occupation = replace(occupation, occupation == '?', NA),\n            native_country = replace(native_country, native_country == '?', NA)\n            )\n\nslice_sample( df.rep[which(is.na(df.rep[\"workclass\"])),], n=10 )\n```\n\nOne alternative can be to use `across(everything())` to replace with `ifelse()`:\n\n```{r}\ndf.rep <- df %>% \n      mutate( across( everything(), ~ ifelse( . == '?', NA, . ) ) )\n\ndf.rep[which(is.na(df.rep[\"workclass\"])),]\n```\n\nTo handle missing values we can drop them, filling them with the previous or next valid value, or replacing them with a statistic value, such as the mean value.\n\n-   `fill()`: Fills missing values in selected columns using the next or previous entry.\n    -   `.direction=` to choose the direction of the fill (down, up, downup, updown).\n\n```{r}\ndf.rep.na.ind <- which(is.na(df.rep[\"occupation\"]))\n\ndf.rep %>% fill (workclass, occupation, native_country,\n                 .direction = \"down\") %>%\n    .[df.rep.na.ind,] %>%\n    slice_sample(n=10)\n```\n\nWhen the variable is categorical it is common to replace the missing values with the most common category. \n\n>Every change in a dataset is a decision that the data scientist has to make and <b>it will certainly affect the result</b>\n\nThis is how we can replace NA with the most frequent value on the categorical variables. First we have to found that value using `table()` with `which.max()`. Then we can use that to replace NA with `replace_na()` pointing both columns.\n\n```{r}\n# Most frequent value\nm.f.workcls <- names( table(df$workclass)[which.max(table(df$workclass))])\nm.f.occp <- names( table(df$occupation)[which.max(table(df$occupation))])\n\n# Replacing NA\ndf.no.na <- df.rep %>% replace_na( list( workclass = m.f.workcls,\n                                         occupation = m.f.occp) )\n\nslice_sample( df.no.na[df.rep.na.ind,], n=10)\n```\n\nAt this point, the data frame only have NA values in native_country. If the NA is less than 5% of the total observation we could drop that observations. With 'workclass' and 'occupation' this percentage was bigger than 5% but on 'native_country' is less than 2%.\n\n```{r}\n# Drop NA\ndf.no.na <- df.no.na %>% drop_na()\n```\n\nExample to extract NA percentage:\n\n```{r}\n# Get proportions with table()\ntable(df.rep$occupation, useNA = 'ifany') %>% prop.table()\n\n# Basic alternative\npaste(\"NA percentage on 'occupation' variable: \",\n    sum(is.na(df.rep$occupation)) / nrow(df.rep) * 100)\n```\n\n# Arranging data\n\n-   `arrange()`: to order a data frame by a column to ascending order\n    -   `desc()`: to change the order to descending\n\n```{r}\ndf.no.na %>% arrange( desc(fnlwgt) ) %>% .[1:10,1:4]\n```\n\nAlso can be useful with `group_by()`, for example:\n\n```{r}\ndf.no.na %>%\n    group_by(marital_status) %>%\n    summarize( count = n() ,\n               avg_net_gain = mean( capital_gain - capital_loss) ) %>%\n    arrange( desc(avg_net_gain) )\n```\n\n# Creating new variables\n\nWe can create new variables such as splitting a column, creating a calculation, encoding text, applying a custom function...\n\n-   `separate()`: to split a column into two column, by default remove the original column.\n    -   `remove=` if `FALSE` to keep the original column\n-   `unite()`: is the complementary function to separate(), is useful to create a unique identifier.\n    -   `sep=` to specify the separator of the new column values\n    -   `remove=FALSE` to keep the original column\n\n```{r}\ndf.no.na %>% separate(target, into = c(\"sign\", \"amount\"), sep = \"\\\\b\") %>%\n    slice_sample(n=10) %>% .[,-(3:14)]\n```\n```{r}\ndf.no.na %>%\n    unite( sex, race, age, col=\"description\", sep=\"_\", remove = FALSE) %>%\n    select(sex, race, age, description, marital_status) %>%\n    slice_sample(n=10)\n```\n\n## The `mutate()` function\n\n-   `mutate()`: designed to create new variables. Also can be used to modified existing variables using the same column name. Given a data frame, then the new variable name equal to the values.\n-   `recode()`: working as a mapping to transform variables\n\nThe new variable which you can create could be whatever are in our mind, a custom function, a simple calculation, a vector...\n\n```{r}\ndf.no.na %>%\n    mutate ( total_gain = capital_gain - capital_loss,\n             tax = ifelse( total_gain >= 15000,\n                           total_gain * 0.21,\n                           total_gain * 0.1) ) %>%\n    slice_sample(n=10) %>% select(total_gain, tax, occupation, age) %>%\n    arrange ( desc(tax) )\n```\n\nCombining `mutate()` and `recode()` to transform values, useful for categories:\n\n```{r}\ndf.no.na %>%\n    mutate( over_under = recode ( target, '<=50'='under', '>50'='over') ) %>%\n    select(target, over_under) %>%\n    slice_sample(n=10)\n```\n\nFor binning a new variable using `mutate()` in combination with `cut()`. To `cut()` will pass the column, a vector with the intervals, and a vector with the name of that intervals.\n\n```{r}\ndf.no.na %>%\n    mutate( age_avg = mean(age), \n            over_under_age_avg = cut( age,\n                                      c(0, mean(age), max(age)),\n                                      c('Lower than avg', 'Above the avg'))) %>%\n    select (age, age_avg, over_under_age_avg) %>%\n    slice_sample(n=10)\n```\n\n# Joining datasets\n\n-   `left_join()`\n-   `right_join()`\n    -   `keep=` if `TRUE` cause the equal variables from both tables to repeat.\n    -   `by=` passing a column to join. It could be passed two column which represent the same values, like `by=c('store_id'='id_store')`\n-   `inner_join()`\n-   `full_join()`\n-   `anti_join()`\n\nIf in the previous join functions we don't pass id= argument, it will determine automatically on which column to join.\n\n```{r}\nsales <- data.frame(\n  date = c(\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"2022-01-04\", \"2022-01-05\"),\n  store_cd= c(1,2,3,4,5),\n  product_cd= c(1,2,3,4,5),\n  qty= c(10, 12, 9, 12,8), \n  sales= c(30, 60, 45, 24, 32)\n  )\n\nstores <- data.frame(\n  store_cd= c(1,2,3,4,6),\n  address= c('1 main st', '20 side st','19 square blvd','101 first st','1002 retail ave'),\n  city= c('Main', 'East', 'West', 'North', 'South'), \n  open_hours= c('7-23', '7-23', '9-21', '9-21', '9-21')\n  )\n\nproducts <- data.frame(\n  product_cd= c(1,2,3,4,6),\n  description= c('Soft drink', 'Frozen snack', 'Fruit', 'Water', 'Fruit 2'),\n  unit_price= c(3.0, 5.0, 5.0, 2.0, 4.0), \n  unit_measure= c('each', 'each', 'kg', 'each', 'kg')\n  )\n```\n\n#### Left Join\n\n```{r}\nsales %>%\n    left_join (products[,1:2], by='product_cd')\n```\n\n#### Right Join\n\n```{r}\nsales %>%\n    select(store_cd, sales) %>%\n    right_join(stores, by = 'store_cd')\n```\n\n#### Full Join\n\n```{r}\nsales %>% full_join(stores)\n```\n\n# Reshaping a table\n\nA data frame in a wide shape is not suitable for machine learning algorithms and for most of the plotting functions. A wide format is when the variable are spread along the rows instead of columns.\n\n-   `pivot_longer()`: given a wide data frame, it will shape it to long format.\n    -   `cols=` to specify which columns should be reshaped, passing a range (`2:6`)\n    -   `names_to=` passing a string as column name for the columns specified in `cols=` argument\n    -   `values_to=` passing a column name for the column representing the values.\n-   `pivot_wider()`: given a long data frame, it will shape it to wide format.\n    -   `names_from=` passing a column name, will take that values to form column names.\n    -   `values_from=` passing a column name, will take that values as values.\n\n# Interesting Tidyverse functions\n\nUsing `data('mtcars')` dataset.\n\nThe `purrr` library contain functions similar to `apply()` family.\n\n-   `map()`: applies the same function to every element of a vector or list.\n\nFrom `dplyr` there are functions similar to `rbind()` and `cbind()`:\n\n-   `bind_rows()`: the data frames must have the same columns\n-   `bind_cols()`: the data frames must have the same number of observations.\n\nFunctions used alongside `mutate()` are cumutalive aggregate functions such as `cumsum(), cumprod(), cummean(), cummax(), cume_dist()`. This functions expect a variable name.\n\n```{r}\nlibrary('datasets')\ndata('mtcars')\n\nmtcars %>% mutate( cumsum_weight = cumsum(wt),\n                   cumpct_weight = cume_dist(wt),\n                   cummean_weight = cummean(wt) ) %>%\n    select(wt, cumsum_weight, cumpct_weight, cummean_weight) %>%\n    slice_sample(n=10) %>%\n    arrange(cumpct_weight)\n```\n\n-   `case_when()`: also from `dplyr.` to deal with multiple cases of logical tests.\n    -   As argument we pass a condition and what will return if it's `TRUE`, separated by `~`\n\n```{r}\nmtcars %>%\n    mutate( transmission_type = case_when ( am == 0 ~ 'automatic',\n                                            am == 1 ~ 'manual' ) ) %>%\n    select(cyl, mpg, am, transmission_type) %>%\n    slice_sample(n=10)\n```\n\n## `ggplot2`\n\nAs a briefly introduction to ggplot2, it is maybe considered one of the best tools for data visualization.\n\nThe syntax is: first, the `ggplot()` functions receives the data. Going forward we must link the layers using '`+`'. Then we choose the geometry corresponding the graphic type. In geometry we pass `aes()` with the axis inside like `aes(x, y, fill)`, and the color, size points and other arguments.\n\nLet's try a scatterplot with mtcars dataset to view the relationship between 'miles per gallon' and 'horsepower':\n\n```{r}\nggplot(data = mtcars) +\n    geom_point( aes( x = hp, y = mpg),\n                color = 'darkblue', size=4, alpha=0.5 ) +\n    ggtitle(\"Relationship between HP vs MPG\")\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\nDataset: https://archive.ics.uci.edu/ml/datasets/Adult\n\n```{r}\n#install.packages('tidyverse')\nlibrary(tidyverse)\n```\n\nTidy data is one observation per row, one measurement or variable per column and one value per cell.\n\n```{r}\nheader <- c(\"age\", \"workclass\", \"fnlwgt\",\"education\",\n\"education_num\", \"marital_status\", \"occupation\",\n\"relationship\", \"race\", \"sex\", \"capital_gain\", \"capital_loss\",\"hours_per_week\", \"native_country\", \"target\")\n\ndf <- read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", col_names = header, \n                   trim_ws = TRUE)\n\nhead(df)\n```\n\n# Slicing and filtering\n\nThe basic form of dplyr for slicing it to use a `.` to consider everything from the object that precedes it. The returned object will be a tibble.\n\n```{r}\ndf %>% .[1:4, c(2:5)]\n```\n\n-   `slice_min(), slice_max()`: to fetch the top or bottom observation given a percentage.\n-   `slice_sample()`: to extract a sample.\n\n```{r}\ndf %>% slice_min(age, prop = 0.15)\n```\n```{r}\ndf %>% slice_sample(n=10, replace = FALSE) %>% .[,1:4]\n```\n\n## Filtering\n\n-   `filter()`: returns rows given a condition.\n-   `select()`: to choose variable to show in the given order.\n\n```{r}\ndf %>%\n  filter( age < 30 ) %>%\n  select( marital_status, age, education ) %>%\n  slice_sample( n = 10)\n```\n\n- distinct(): to extract unique values.\n\n```{r}\ndf %>% distinct(sex) \n```\n\n# Grouping and summarizing data\n\nThe next functions are complementary, usually used together.\n\n-   `group_by()`: to group a variable by its values\n-   `summarize()`: given a function with a variable returns the result.\n-   `ungroup()`: after `group_by()` with more than one variable, it returns a `tbl_df`. The ungrouped tibble requires less memory space than the tibble one.\n\n```{r}\ndf %>% group_by(workclass) %>% .[1:10,1:4]\n```\n```{r}\ndf %>% group_by(sex) %>% summarise( avg_age = mean(age), sd_age = sd(age))\n```\n```{r}\nmarital.groups <- df %>% group_by(marital_status, sex) %>%\n  summarize( avg_age = mean(age) )\nmarital.groups\n```\n```{r}\nungroup(marital.groups)\n```\n\n-   `quantile()`: returns the number corresponding the passing percentage.\n-   `first()`: returns the first number. Combined with `group_by()` returns the first number of each group.\n-   `across()`: applies a function to the selected columns.\n\n```{r}\ndf %>% group_by(marital_status) %>% summarise(first(age))\n```\n```{r}\ndf %>% group_by(sex) %>% summarise( \"50%\" = quantile(age, 0.5))\n```\n```{r}\ndf %>% select(1,3,5,11,12,13) %>%\n  summarise( across(everything(), mean) )\n```\n\n# Replacing and Filling Data\n\nA dataset will be imperfect, in this case we have '?' instead of NA. First, the character '?' has to be replaced with NA and then we can replace NA with other character.\n\n```{r}\nfor (var in colnames(df) ) {\n    print(\n        paste (var, nrow( df[df[var] == '?', ] ) )\n    )\n}\n```\n\nIn the output we can see the missing values represented with '?': \"workclass 1836\", \"occupation 1843\", and \"native_country 583\". Now we can use `mutate()` to edit the columns affected.\n\n```{r}\ndf.rep <- df %>%\n    mutate (workclass = replace(workclass, workclass == '?', NA),\n            occupation = replace(occupation, occupation == '?', NA),\n            native_country = replace(native_country, native_country == '?', NA)\n            )\n\nslice_sample( df.rep[which(is.na(df.rep[\"workclass\"])),], n=10 )\n```\n\nOne alternative can be to use `across(everything())` to replace with `ifelse()`:\n\n```{r}\ndf.rep <- df %>% \n      mutate( across( everything(), ~ ifelse( . == '?', NA, . ) ) )\n\ndf.rep[which(is.na(df.rep[\"workclass\"])),]\n```\n\nTo handle missing values we can drop them, filling them with the previous or next valid value, or replacing them with a statistic value, such as the mean value.\n\n-   `fill()`: Fills missing values in selected columns using the next or previous entry.\n    -   `.direction=` to choose the direction of the fill (down, up, downup, updown).\n\n```{r}\ndf.rep.na.ind <- which(is.na(df.rep[\"occupation\"]))\n\ndf.rep %>% fill (workclass, occupation, native_country,\n                 .direction = \"down\") %>%\n    .[df.rep.na.ind,] %>%\n    slice_sample(n=10)\n```\n\nWhen the variable is categorical it is common to replace the missing values with the most common category. \n\n>Every change in a dataset is a decision that the data scientist has to make and <b>it will certainly affect the result</b>\n\nThis is how we can replace NA with the most frequent value on the categorical variables. First we have to found that value using `table()` with `which.max()`. Then we can use that to replace NA with `replace_na()` pointing both columns.\n\n```{r}\n# Most frequent value\nm.f.workcls <- names( table(df$workclass)[which.max(table(df$workclass))])\nm.f.occp <- names( table(df$occupation)[which.max(table(df$occupation))])\n\n# Replacing NA\ndf.no.na <- df.rep %>% replace_na( list( workclass = m.f.workcls,\n                                         occupation = m.f.occp) )\n\nslice_sample( df.no.na[df.rep.na.ind,], n=10)\n```\n\nAt this point, the data frame only have NA values in native_country. If the NA is less than 5% of the total observation we could drop that observations. With 'workclass' and 'occupation' this percentage was bigger than 5% but on 'native_country' is less than 2%.\n\n```{r}\n# Drop NA\ndf.no.na <- df.no.na %>% drop_na()\n```\n\nExample to extract NA percentage:\n\n```{r}\n# Get proportions with table()\ntable(df.rep$occupation, useNA = 'ifany') %>% prop.table()\n\n# Basic alternative\npaste(\"NA percentage on 'occupation' variable: \",\n    sum(is.na(df.rep$occupation)) / nrow(df.rep) * 100)\n```\n\n# Arranging data\n\n-   `arrange()`: to order a data frame by a column to ascending order\n    -   `desc()`: to change the order to descending\n\n```{r}\ndf.no.na %>% arrange( desc(fnlwgt) ) %>% .[1:10,1:4]\n```\n\nAlso can be useful with `group_by()`, for example:\n\n```{r}\ndf.no.na %>%\n    group_by(marital_status) %>%\n    summarize( count = n() ,\n               avg_net_gain = mean( capital_gain - capital_loss) ) %>%\n    arrange( desc(avg_net_gain) )\n```\n\n# Creating new variables\n\nWe can create new variables such as splitting a column, creating a calculation, encoding text, applying a custom function...\n\n-   `separate()`: to split a column into two column, by default remove the original column.\n    -   `remove=` if `FALSE` to keep the original column\n-   `unite()`: is the complementary function to separate(), is useful to create a unique identifier.\n    -   `sep=` to specify the separator of the new column values\n    -   `remove=FALSE` to keep the original column\n\n```{r}\ndf.no.na %>% separate(target, into = c(\"sign\", \"amount\"), sep = \"\\\\b\") %>%\n    slice_sample(n=10) %>% .[,-(3:14)]\n```\n```{r}\ndf.no.na %>%\n    unite( sex, race, age, col=\"description\", sep=\"_\", remove = FALSE) %>%\n    select(sex, race, age, description, marital_status) %>%\n    slice_sample(n=10)\n```\n\n## The `mutate()` function\n\n-   `mutate()`: designed to create new variables. Also can be used to modified existing variables using the same column name. Given a data frame, then the new variable name equal to the values.\n-   `recode()`: working as a mapping to transform variables\n\nThe new variable which you can create could be whatever are in our mind, a custom function, a simple calculation, a vector...\n\n```{r}\ndf.no.na %>%\n    mutate ( total_gain = capital_gain - capital_loss,\n             tax = ifelse( total_gain >= 15000,\n                           total_gain * 0.21,\n                           total_gain * 0.1) ) %>%\n    slice_sample(n=10) %>% select(total_gain, tax, occupation, age) %>%\n    arrange ( desc(tax) )\n```\n\nCombining `mutate()` and `recode()` to transform values, useful for categories:\n\n```{r}\ndf.no.na %>%\n    mutate( over_under = recode ( target, '<=50'='under', '>50'='over') ) %>%\n    select(target, over_under) %>%\n    slice_sample(n=10)\n```\n\nFor binning a new variable using `mutate()` in combination with `cut()`. To `cut()` will pass the column, a vector with the intervals, and a vector with the name of that intervals.\n\n```{r}\ndf.no.na %>%\n    mutate( age_avg = mean(age), \n            over_under_age_avg = cut( age,\n                                      c(0, mean(age), max(age)),\n                                      c('Lower than avg', 'Above the avg'))) %>%\n    select (age, age_avg, over_under_age_avg) %>%\n    slice_sample(n=10)\n```\n\n# Joining datasets\n\n-   `left_join()`\n-   `right_join()`\n    -   `keep=` if `TRUE` cause the equal variables from both tables to repeat.\n    -   `by=` passing a column to join. It could be passed two column which represent the same values, like `by=c('store_id'='id_store')`\n-   `inner_join()`\n-   `full_join()`\n-   `anti_join()`\n\nIf in the previous join functions we don't pass id= argument, it will determine automatically on which column to join.\n\n```{r}\nsales <- data.frame(\n  date = c(\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"2022-01-04\", \"2022-01-05\"),\n  store_cd= c(1,2,3,4,5),\n  product_cd= c(1,2,3,4,5),\n  qty= c(10, 12, 9, 12,8), \n  sales= c(30, 60, 45, 24, 32)\n  )\n\nstores <- data.frame(\n  store_cd= c(1,2,3,4,6),\n  address= c('1 main st', '20 side st','19 square blvd','101 first st','1002 retail ave'),\n  city= c('Main', 'East', 'West', 'North', 'South'), \n  open_hours= c('7-23', '7-23', '9-21', '9-21', '9-21')\n  )\n\nproducts <- data.frame(\n  product_cd= c(1,2,3,4,6),\n  description= c('Soft drink', 'Frozen snack', 'Fruit', 'Water', 'Fruit 2'),\n  unit_price= c(3.0, 5.0, 5.0, 2.0, 4.0), \n  unit_measure= c('each', 'each', 'kg', 'each', 'kg')\n  )\n```\n\n#### Left Join\n\n```{r}\nsales %>%\n    left_join (products[,1:2], by='product_cd')\n```\n\n#### Right Join\n\n```{r}\nsales %>%\n    select(store_cd, sales) %>%\n    right_join(stores, by = 'store_cd')\n```\n\n#### Full Join\n\n```{r}\nsales %>% full_join(stores)\n```\n\n# Reshaping a table\n\nA data frame in a wide shape is not suitable for machine learning algorithms and for most of the plotting functions. A wide format is when the variable are spread along the rows instead of columns.\n\n-   `pivot_longer()`: given a wide data frame, it will shape it to long format.\n    -   `cols=` to specify which columns should be reshaped, passing a range (`2:6`)\n    -   `names_to=` passing a string as column name for the columns specified in `cols=` argument\n    -   `values_to=` passing a column name for the column representing the values.\n-   `pivot_wider()`: given a long data frame, it will shape it to wide format.\n    -   `names_from=` passing a column name, will take that values to form column names.\n    -   `values_from=` passing a column name, will take that values as values.\n\n# Interesting Tidyverse functions\n\nUsing `data('mtcars')` dataset.\n\nThe `purrr` library contain functions similar to `apply()` family.\n\n-   `map()`: applies the same function to every element of a vector or list.\n\nFrom `dplyr` there are functions similar to `rbind()` and `cbind()`:\n\n-   `bind_rows()`: the data frames must have the same columns\n-   `bind_cols()`: the data frames must have the same number of observations.\n\nFunctions used alongside `mutate()` are cumutalive aggregate functions such as `cumsum(), cumprod(), cummean(), cummax(), cume_dist()`. This functions expect a variable name.\n\n```{r}\nlibrary('datasets')\ndata('mtcars')\n\nmtcars %>% mutate( cumsum_weight = cumsum(wt),\n                   cumpct_weight = cume_dist(wt),\n                   cummean_weight = cummean(wt) ) %>%\n    select(wt, cumsum_weight, cumpct_weight, cummean_weight) %>%\n    slice_sample(n=10) %>%\n    arrange(cumpct_weight)\n```\n\n-   `case_when()`: also from `dplyr.` to deal with multiple cases of logical tests.\n    -   As argument we pass a condition and what will return if it's `TRUE`, separated by `~`\n\n```{r}\nmtcars %>%\n    mutate( transmission_type = case_when ( am == 0 ~ 'automatic',\n                                            am == 1 ~ 'manual' ) ) %>%\n    select(cyl, mpg, am, transmission_type) %>%\n    slice_sample(n=10)\n```\n\n## `ggplot2`\n\nAs a briefly introduction to ggplot2, it is maybe considered one of the best tools for data visualization.\n\nThe syntax is: first, the `ggplot()` functions receives the data. Going forward we must link the layers using '`+`'. Then we choose the geometry corresponding the graphic type. In geometry we pass `aes()` with the axis inside like `aes(x, y, fill)`, and the color, size points and other arguments.\n\nLet's try a scatterplot with mtcars dataset to view the relationship between 'miles per gallon' and 'horsepower':\n\n```{r}\nggplot(data = mtcars) +\n    geom_point( aes( x = hp, y = mpg),\n                color = 'darkblue', size=4, alpha=0.5 ) +\n    ggtitle(\"Relationship between HP vs MPG\")\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"11_transformations_tidyverse.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","bibliography":["../../references.bib"],"editor":"visual","tabset":true,"theme":{"light":["cosmo","../../style/style.scss"],"dark":["cosmo","../../style/dark.scss"]},"title":"Transformations with Tidyverse"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"11_transformations_tidyverse.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["../../references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Transformations with Tidyverse"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}