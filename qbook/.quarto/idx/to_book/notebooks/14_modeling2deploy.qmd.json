{"title":"Modeling to Deploy","markdown":{"yaml":{"title":"Modeling to Deploy"},"headingText":"Building a Model","containsRefs":false,"markdown":"\n\n\n#### Dataset {.unnumbered}\n\nHopkins, M., Reeber, E., Forman, G., & Suermondt, J. (1999). Spambase [Dataset]. UCI Machine Learning Repository. <https://doi.org/10.24432/C53G6X> .\n\n#### Libraries {.unnumbered}\n\n```{r message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(skimr)\nlibrary(randomForest)\nlibrary(caret)\nlibrary(ROCR)\n```\n\n## Machine Learning concepts\n\nModeling data involves finding patterns that can help us explain a response (most probable outcome). One of the most important things is that the input data is clean and representative of the reality we are trying to model.\n\n-   **Classification models**: Used for categorical output. We transform the input data into patterns that will be separated into groups. Thus, each observation will be classified into a group, according to its patterns.\n    -   KNN, decision tree, random forest, logistic regression, and support vector machine.\n-   **Regression models**: Used for numerical output. It will find patterns in number and return a continuous output. As summary, it will captures the relationship between the input variables and calculate an estimate of the output.\n    -   Linear regression, polynomial regression, and regression tree.\n\nAlgorithm types:\n\n-   **Supervised**: algorithm which receives data containing variables that can explain an outcome, the content and the answers to learn. Once it learn the patterns, with new data it will generalize the solution. Can be used classification and regression models.\n-   **Unsupervised**: algorithm which do not receive labeled variable, instead read the dataset looking for patterns that can help explain the data. Clustering models use this algorithm.\n-   **Reinforcement**: algorithm which learn by trial and error. It will perform an actions and check how its going. Positive is rewarded, negative is penalized. It tries to reduce the penalties to the minimum possible. Useful for video games.\n\n## Understanding the project\n\n>When starting a project, we need a purpose which is the goal we want to reach at the end.\n\n### The dataset\n\n```{r message=FALSE, warning=FALSE}\nurl.data <- \"https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.data\" \n\nurl.names <- \"https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.names\"\n\nnames <- read_table(url.names, col_names = FALSE) %>% suppressWarnings()\nnames <- names %>% filter(X2 == \"continuous.\") %>% select(X1)\nnames <- names %>% mutate(X1 = gsub(pattern = \"\\\\:\", replacement = \"\", x = X1) )\n\ndf <- read_csv(url.data, \n               col_names = c(names[[\"X1\"]], \"spam_cat\"), \n               trim_ws = TRUE) %>% suppressWarnings()\n\nglimpse(df)\n```\n\nThere are 58 column, the last column 'spam_cat' is the target, which is a label classification of spam (1) or not spam (0).\n\n```{r}\ndim(df)\n```\n\nEach variable represents specific words associated with spam and their percentage present in the message.\n\n### The project\n\nObjective: Create a spam detector using AI models. Create a tool that can get any text as input and estimates the probability of that message being classified as spam or not.\n\n\nCase: Company which send a lot of commercial email wants to reduce their emails to be spam. The dataset provided by the company contain some words with percentages and if were classified as spam or not.\n\n### The algorithm\n\nThis is a classification problem, then It has to be used a model which classifies. Random Forest will be it.\n\n## Preparing data for modeling\n\nWe know our objective, then we have to wrangle the data to get there.\n\n-   `tidyverse`: data wrangling and visualization.\n-   `skimr`: create descriptive statistics summary.\n-   `patchwork`: to put graphics side by side.\n-   `randomForest`: to create the model.\n-   `caret`: to create the confusion matrix.\n-   `ROCR`: to plot ROC curve.\n\n```{r}\ndim(df)   # Dataset previously loaded\n```\n```{r}\nglimpse(df)\n```\n\nVariables representing frequencies will maintain the double class, capital* variable will be set to Integer and spam_cat to factor.\n\n```{r}\nvars.int <- c(\"capital_run_length_average\", \n              \"capital_run_length_longest\", \n              \"capital_run_length_total\")\ndf <- df %>%\n  mutate_at(\"spam_cat\", as.factor) %>%\n  mutate_at(vars.int, as.integer)\n\nanyNA(df)\n```\n\nThere are no missing values NA, then we can proceed with descriptive statistics using skim().\n\n```{r}\n# Disable scientific notion\noptions( scipen = 999, digits = 4 )\n\nskim(df)\n```\n\n-   Most of the p50 and p75 values are close to 0, meanwhile the mean is higher. Suggests a high right tail on the data.\n-   There are 1813 spam emails (39.4%)\n-   High Standard deviation suggests outliers and spread data.\n\n## Exploring the data with visuals\n\n\n```{r}\nfor (var in colnames(select_if(df[,1:47], is.numeric) ) ) {\n    hist( unlist( df[,var]), col = \"blue\",\n          main = paste(\"Histogram of\", var),\n          xlab = var)\n}\n```\n\nTo use ggplot2 we need that dataset in tidy format, to do that we must convert this wide format to long format with the columns *spam* for 'spam_cat', *word* for every column name, and *freq* for the values.\n\n```{r}\ndf.long <- df %>%\n    pivot_longer( cols = 1:57, names_to = \"words\", values_to = \"pct\")\nhead(df.long, 9)\n```\n\nNow its ready for plotting with ggplot2, then we can create boxplots. Boxplot are useful to see the outliers that can distort our classifier (Random Forest), also which words appear more frequently which impact the classification. We can filter only the 'word_' from words column and `spam==1`.\n\n```{r fig.height=14, fig.width=7}\ndf.long %>%\n    filter( str_detect(words, \"word_\") & spam_cat == 1) %>%\n    ggplot() +\n        geom_boxplot( aes( y = reorder(words, pct), x = pct, fill = spam_cat ) ) +\n        labs( title = \"Percentages of words and their association with spam emails\",\n              subtitle = \"The frequency of appearance of some words in emails is more associated with spam\",\n              x = \"Percentage\",\n              y = \"Word\" ) +\n        theme_classic() +\n        theme( plot.subtitle = element_text( color = \"darkgray\", size = 10 ),\n               legend.position = \"none\")\n```\n\nAfter the 24th record all the boxplots have their medians too close to zero, so they do not impact the spam classification too much. Then we know that the top 23 words can have more impact so we have to compare spam and not spam in this words to see how they impact the entire data.\n\n```{r}\ntemp <- df.long %>% \n    filter( str_detect(words, \"word_\") & spam_cat == 1) %>%\n    group_by(words) %>% \n    summarise( pct_sum = sum(pct) ) %>%\n    arrange( desc(pct_sum) )\n\ntop.words <- c(temp$words[1:23], \"spam_cat\")\nremove(temp)\n```\n\nIn this next code we generate a boxplot comparing spam and not spam only on the selected top words. It can be seen as a focus to see more easily the differences.\n\n```{r}\ndf.top <- df %>%\n    select( all_of(top.words) ) %>%\n    mutate( top_words_pct = rowSums( across( where(is.numeric) ) ) )\n\ng1 <- ggplot(df.top) + \n    geom_boxplot( aes( y = factor(spam_cat), x = top_words_pct),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How the presence of words associated with spam emails \n          impacts the classification (TOP23)\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those words.\") +\n    theme_classic()\n```\n\nIn the same way with this second boxplot we compare spam and not spam but with all the words.\n\n```{r}\ndf.2 <- df %>%\n    mutate(word_pct = rowSums( across( where(is.numeric) ) ) )\n\ng2 <- ggplot(df.2) +\n    geom_boxplot( aes( y = factor(spam_cat), x = word_pct ),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How spam associated words impacts the classification\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those words.\") +\n    theme_classic()\n```\n\n```{r fig.width=10}\n# Patchwork library, putting the objects into a parenthesis with a pipe\n\n(g1 | g2)\n```\n\nIt can be seen a large median of those words dissociated with spam emails. To be sure that difference is statistically significant we can perform Kolmogorov-Smirnov test which compare distributions, or U-Mann Whitney which compare medians.\n\n```{r}\npos.spam <- df.top[df.top[\"spam_cat\"] == 1,][[\"top_words_pct\"]]\nneg.spam <- df.top[df.top[\"spam_cat\"] == 0,][[\"top_words_pct\"]]\n\nks.test(pos.spam, neg.spam)\nwilx <- wilcox.test(pos.spam, neg.spam)\nwilx\n# Size effect formula by Wendt\nrbis <- sum(-1, (2 * wilx$statistic) / (length(pos.spam) * length(neg.spam)) )\ncat(\"U Mann Whitney effect size r = \", rbis)\n\n```\n\nBoth test show p < 0.05 thus both groups have different distribution and median according to KS-test and U Mann Whitney test respectively. Also, the size effect Biserial-Rank correlation of U Mann-Whitney is big meaning there are a significance difference between the groups. The spam group values tend to be considerably bigger than no-spam group. Then, the variable spam have a high impact in the difference of the groups.\n\nSince we know the words impact now we can test the characters in a similar way:\n\n```{r}\ndf.long %>%\n    filter( str_detect(words, \"char_\") & spam_cat == 1) %>%\n    ggplot() +\n        geom_boxplot( aes( y = reorder(words, pct), x = pct, fill = spam_cat ) ) +\n        labs( title = \"Percentages of special characters and their association with spam emails\",\n              subtitle = \"The frequency of appearance of some characters in emails is more associated with spam\",\n              x = \"Percentage\",\n              y = \"Character\" ) +\n        theme_classic() +\n        theme( plot.subtitle = element_text( color = \"darkgray\", size = 10 ),\n               legend.position = \"none\")\n```\n\n```{r}\ndf.char <- df %>%\n    select_if(str_detect(colnames(df), pattern = \"char_|^spam_cat\")) %>%\n    mutate( char_pct = rowSums( across( where(is.numeric) ) ) )\n\ng3 <- ggplot(df.char) + \n    geom_boxplot( aes( y = factor(spam_cat), x = char_pct),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How the presence of characters associated with spam emails \n          impacts the classification\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those characters.\") +\n    theme_classic()\n\ng3\n```\n\n```{r}\ndf.char.zero <- df.char %>% filter(spam_cat == 0)\ndf.char.one <- df.char %>% filter(spam_cat == 1)\n\nfor (var in colnames(df.char.zero[,1:6])) {\n    wilx <- wilcox.test(df.char.zero[[var]], df.char.one[[var]])\n    rbis <- abs(sum(-1, (2 * wilx$statistic) / (length(pos.spam) * length(neg.spam)) ))\n    cat(\"\\nMann-Whitney U between spam and not spam on:\", var, \n        \"\\np-value:\", sprintf(\"%6.4f\", wilx$p.value),\n        \"\\nr:\", rbis)\n}\n```\n\n```{r fig.height=6, fig.width=8}\ng4 <- df.char.zero %>% \n    pivot_longer(cols = 1:6, names_to = \"chars\", values_to = \"pct\") %>%\n    ggplot() +\n    geom_boxplot( aes( y = chars, x = pct) ) +\n    labs( y = \"Characters in not spam emails\",\n          x = \"\") +\n    theme_classic()\n\ng5 <- df.char.one %>% \n    pivot_longer(cols = 1:6, names_to = \"chars\", values_to = \"pct\") %>%\n    ggplot() +\n    geom_boxplot( aes( y = chars, x = pct) ) +\n    labs( x = \"Frequencies\",\n          y = \"Characters in spam emails\") +\n    theme_classic()\n\n(g4 / g5)\n```\n\n\nAt this point we know that the number of symbols, and words are statistically different for each group in our classification.\n\n## Selecting the best variables\n\nWhen we checked the variables with boxplots and test comparisons we show how them impact the classifications the most. We should use those variables that have the highest difference between both groups so that it's easier for the algorithm to find a clearer separations between the two groups. The conclusion we show is that 23 words maximize the difference as well as uppercase and the presence of too many symbols.\n\nWe are prepare to create a dataset for modeling. Taking the original dataframe, binding top_words_pct, the target variable, the character and uppercase variables:\n\n```{r}\ndf.model <- df %>%\n    bind_cols( top_words_pct = df.top$top_words_pct ) %>%\n    select( spam_cat, top_words_pct, \n            `char_freq_!`, `char_freq_(`, `char_freq_$`,\n            capital_run_length_total, capital_run_length_longest ) %>%\n    mutate(spam_cat = ifelse(spam_cat == 1, \"is_spam\", \"no_spam\")) %>%\n    mutate_at(vars(spam_cat), as.factor)\n\n\ncolnames(df.model)[3:5] <- c(\"char_freq_exclam\", \"char_freq_paren\", \"char_freq_dollar\")\nslice_sample(df.model, n = 9)\n```\n\n## Modeling\n\n### Training\n\nIn the last code we just replace 1 with 'is_spam' and 0 with 'no_spam'. This is necessary for random forest in this case to classify.\n\n```r\n# Alternative code to replace values:\ndf.model <- df.model %>%\n    mutate( spam_cat = recode(spam_cat, '1'=\"is_spam\", '0'=\"no_spam\") )\n```\n\n-   train: subset used to present the model with the patterns and the labels associated with it so that it can study how to classify each observation according to the patterns that occur.\n-   test: subset where new data is presented to the trained model so that we can measure how accurate it is or how much it has learned.\n\nThe dataset have aprox 60-40 as not-spam and spam respectively. In this case, we won't apply any category balancing technique, this imbalance will not affect the result.\n\n**In R there is no function for splitting the dataset into train and test**\n\nWe are going to use 80% for training and 20% for testing.\n\n```{r}\nn.rows <- nrow(df.model)\nidx <- sample(1:n.rows, size = 0.8 * n.rows)\n\ntrain.80 <- df.model[idx,]\ntest.20 <- df.model[-idx,]\n```\n\nNow we can check if the proportions are similar to the original dataset:\n\n```{r}\nwriteLines(\"Original set:\")\nprop.table( table(df$spam_cat) )\nwriteLines(\"==================\")\nwriteLines(\"Train set:\")\nprop.table( table(train.80$spam_cat) )\nwriteLines(\"==================\")\nwriteLines(\"Test set:\")\nprop.table( table(test.20$spam_cat) )\n```\n\n-   `randomForest()` It must be passed the target variable with `~ .` meaning the target will be explained by the rest of the data represented with '`.`'\n    -   `data=` the data set to use, will be the training set.\n    -   `importance=` if TRUE it will calculate the importance of the variables.\n    -   `ntree=` the number of decision trees to create with this model.\n    \n```{r}\nmodel.rf <- randomForest( spam_cat ~ ., data = train.80,\n                          importance = TRUE,\n                          ntree = 250)\n```\n```{r}\nplot(model.rf)\n```\n\nThis plot shows the performance of the model. After the 50th tree, the error stabilizes.\n\n-   `varImpPlot()`: to plot the feature's importance or which variables are more importance to the model.\n\n```{r fig.width=8}\nvarImpPlot(model.rf)\n```\n\nThis plot shows the importance of each variable.\n\n-   Mean Decrease Accuracy: it calculates how much the model's accuracy decreases when the values of a particular feature are randomly shuffled. A higher value indicates that a feature is more important for the model's accuracy. Then the model relies heavily on that features to make accurate predictions.\n-   Mean Decrease Gini: A higher value indicates that a feature is more important for the model's ability to separate the classes. Features with high MeanDecreaseGini values are those that are useful for creating decision boundaries in the model.\n\nFor the library `randomForest` the default for classification models is the Gini index.\n\n### Testing and evaluating the model\n\nThe most used metrics to evaluate a classification model are *accuracy, confusion matrix, and ROC curve*. \n-   `predict()`: to generate a prediction given as arguments the model and the test set. The object assigned can be used to extract information.\n\n-   `confusionMatrix()`: given a prediction and the target column from the test set shows the information of that prediction.\n\n```{r}\n# Prediction:\nmodel.preds <- predict(model.rf, test.20)\n\nconfusionMatrix(model.preds, test.20$spam_cat, positive = \"no_spam\")\n```\n\nThe confusion matrix show how were the prediction. For 'is_spam' predicted value are 315 'is_spam' as reference, then this 315 are True Positive. The next value is for the predicted 'is_spam' and 'no_spam' as reference with 38 matches, corresponding False Positive known as Type 1 Error. The next two values are False Negative (Type 2 Error) and True Negative with 52 and 516 matches respectively.\n\nThe accuracy is 0.9 aprox, then out of the 100 predictions, there will be around 10 errors with a confidence interval about 12 to 8 errors.\n\n-   **Accuracy**: How many of the total number of classifications the model predicted correctly. Is an overall sense of the model's performance.\n-   **Sensitivity** and **Specificity**: provide insights into the model's performance on the positive and negative classes, respectively. In many cases, depending on the problem, one metric or the other will be more important. (e.g. Medicine, the true positive rate might be more critical then we'll look sensitivity.)\n-   **Kappa**: by accounting for chance agreement helps us to understand the model's performance. A high kappa indicates a strong agreement between the predicted and actual labels.\n-   **Balanced Accuracy**: useful when the labels are unbalanced. It provides a balanced measure of the model's performance.\n\nThe relatively high accuracy (0.902) and a strong kappa value (0.795), it suggests that the model is performing well overall. The sensitivity (0.858) and specificity (0.931) values indicate that the model detect both positive and negative instances quite well.\n\nNow it's time to look at ROC curve to check the performance based on the rate of true positive and false positives (Sensitivity and Specificity).\n\n-   `prediction()` given the data frame with probability predictions with the positive class ('no_spam' according to confusionMatrix) and the real labels which is the test set selecting the target.\n-   `performance()` given the object with `prediction()` and the labels for the axes which are 'tpr' and 'fpr' for true positive rate and false positive rate.\n-   `abline()` for the visualization will draw a diagonal that separates the graphic 50/50\n\n```{r}\nmodel.df.preds <- data.frame( predict(model.rf, test.20, type='prob') )\n\nmodel.roc <- prediction(model.df.preds$no_spam, test.20$spam_cat)\n\nroc <- performance(model.roc, 'tpr', 'fpr')\nauc <- performance(model.roc, \"auc\")\nplot(roc, colorize = T, lwd = 2,\n     main = \"ROC curve. 'no_spam' as positive class.\",\n     sub = paste( \"AUC =\", auc@y.values[[1]]) )\nabline(0.0, 1.0)\n```\n\nAt the bottom we can see the Area Under the Receiver Operating Characteristic Curve (AUC-ROC). If `AUC=1` represents a perfect classifier meanwhile `AUC=0.5` is a random classifier. In this case is a pretty good classier, this value indicates the performance of the classifier.\n\n### Predicting\n\nAfter evaluating, it's time to test the model. \n\nThe input to predict must to be in the very same format as the data frame used in the Random Forest. Then, if we did any transformations this have to be repeated before we can input the new data.\n\nTo do that, we can create a custom function with the steps of preparation and modeling that we took until create 'df.model'. To that custom function we pass whatever we want to predict depending the objective (spam in this case, then we pass a mail) and the function will perform every step to model the data.\n\nThe next function called `prepare_input()` is from this book's code, which takes a string of text and the spam_words vector as input. Then, it reads the text and it will count the selected columns we modeled before, such as !, $, (), uppercase letters, the longest sequence of uppercase, and words in the spam list. Finally, returning a data frame for input in the model we create.\n\n```{r echo=FALSE}\n# Creating a function to prepare any text for input in the model\nprepare_input <- function (text, spam_words){\n  \"This function takes a string text as input, counts the quantities of !, $, (), uppercase letters, longest sequence of uppercase, words in the spam list.\n  * Input: string\n  * Returns: data frame for input in the RF model\"\n  \n  # Counts of the punctuation\n  exclamation <- str_count(text, pattern=\"[!]\")\n  parenthesis <-  str_count(text, pattern=\"[()]\")\n  dollar_sign <-  str_count(text, pattern=\"[$]\")\n  \n  # Counts of UPPERCASE\n  total_uppercase <- str_count(text, \"[A-Z]\")\n  \n  # Remove punctuation for total words count\n  text_no_puncuation <- str_remove_all(text, pattern=\"[:punct:]|[$]*\")\n  \n  #longest_uppercase\n  all_words <- str_split(text_no_puncuation, \" \")\n  all_words <- all_words[[1]]\n  \n  # Create a vector with all the uppercase counts\n  char_counts <- c()\n  for (word in all_words) {\n    if (word == toupper(word)) {\n      char_counts <- c(char_counts, nchar(word))\n    } #enf if\n  }#end for\n  \n  # Get only the longest uppercase word size\n  if (max(char_counts) < 0) {\n    longest_upper <- 0} else {longest_upper <- max(char_counts)}\n  \n  \n  # Count how many spam words are in the text\n  # Create a counter of spam words\n  top_w <- 0\n  # For each word\n  for (word in all_words) {\n    # if word is in the spam list, count +1\n    if (tolower(word) %in% spam_words) {\n      top_w <- top_w + 1\n    } #enf if\n  }#end for\n  \n  # Determine length of the text\n  text_length <- length(all_words)\n  \n  # Create a data frame with all counts in percentages (divided by the text length)\n  input <- data.frame(top_words_pct= 100*top_w / text_length,\n                      char_freq_exclam= 100*exclamation / text_length,\n                      char_freq_paren= 100*parenthesis / text_length,\n                      char_freq_dollar= 100*dollar_sign / text_length,\n                      capital_run_length_total= total_uppercase,\n                      capital_run_length_longest= longest_upper )\n  \nreturn(input)\n} #end function\n\n```\n\nThe next objects will be the emails to check and the spam_words to use:\n\n```{r}\n\ntext1 <- 'SALE!! SALE!! SALE!! SUPER SALEEEE!! This is one of the best sales of the year! More than #3000# products with discounts up to $500 off!! Visit our page and Save $$$ now! Order your product NOW (here) and get one for free !'\n\ntext2 <- 'DEAR MR. JOHN, You will find enclosed the file we talked about during your meeting earlier today. The attachment received here is also available in our web site at this address: www.DUMMYSITE.com. Sale.'\n\nspam.words <- c('you', 'your', 'will', 'free', 'our', 'all', 'mail', 'email', 'business', 'remove', '000', 'font', 'money', 'internet', 'credit', 'over', 'order', '3d', 'address', 'make', 'people', 're', 'receive', 'sale')\n```\n\nIt is time to predict: \n\n```{r}\ninput <- prepare_input(text1, spam.words)\n\ndata.frame( predict(model.rf, input, type = \"prob\") )\n```\n```{r}\ninput <- prepare_input(text2, spam.words)\n\ndata.frame( predict(model.rf, input, type = \"prob\") )\n```\n\nWe can see in this case that spam email (text1) is with 70% probability spam, although text2 which is no spam the model tell us is with 0.51% no spam. Looking the text2 there are some uppercase letters which can fool the model a little bit.\n\nThe next step is save this model and be ready for deployment. To save the model we can use `saveRDS()` function and input the model's name and the name of the output filename. Later with Shiny application we can deploy the model to do it's job (receiving emails from a user or whatever).\n\n```{r}\nsaveRDS(model.rf, \"../scripts/model_rf_spam.rds\")\n```\n\n## Useful Links\n\n-   Mode deep in Supervised and Unsupervised learning, with evaluation measures: https://www.geeksforgeeks.org/supervised-unsupervised-learning/\n\n\n\n# Build an Application with Shiny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n# Building a Model\n\n#### Dataset {.unnumbered}\n\nHopkins, M., Reeber, E., Forman, G., & Suermondt, J. (1999). Spambase [Dataset]. UCI Machine Learning Repository. <https://doi.org/10.24432/C53G6X> .\n\n#### Libraries {.unnumbered}\n\n```{r message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(skimr)\nlibrary(randomForest)\nlibrary(caret)\nlibrary(ROCR)\n```\n\n## Machine Learning concepts\n\nModeling data involves finding patterns that can help us explain a response (most probable outcome). One of the most important things is that the input data is clean and representative of the reality we are trying to model.\n\n-   **Classification models**: Used for categorical output. We transform the input data into patterns that will be separated into groups. Thus, each observation will be classified into a group, according to its patterns.\n    -   KNN, decision tree, random forest, logistic regression, and support vector machine.\n-   **Regression models**: Used for numerical output. It will find patterns in number and return a continuous output. As summary, it will captures the relationship between the input variables and calculate an estimate of the output.\n    -   Linear regression, polynomial regression, and regression tree.\n\nAlgorithm types:\n\n-   **Supervised**: algorithm which receives data containing variables that can explain an outcome, the content and the answers to learn. Once it learn the patterns, with new data it will generalize the solution. Can be used classification and regression models.\n-   **Unsupervised**: algorithm which do not receive labeled variable, instead read the dataset looking for patterns that can help explain the data. Clustering models use this algorithm.\n-   **Reinforcement**: algorithm which learn by trial and error. It will perform an actions and check how its going. Positive is rewarded, negative is penalized. It tries to reduce the penalties to the minimum possible. Useful for video games.\n\n## Understanding the project\n\n>When starting a project, we need a purpose which is the goal we want to reach at the end.\n\n### The dataset\n\n```{r message=FALSE, warning=FALSE}\nurl.data <- \"https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.data\" \n\nurl.names <- \"https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.names\"\n\nnames <- read_table(url.names, col_names = FALSE) %>% suppressWarnings()\nnames <- names %>% filter(X2 == \"continuous.\") %>% select(X1)\nnames <- names %>% mutate(X1 = gsub(pattern = \"\\\\:\", replacement = \"\", x = X1) )\n\ndf <- read_csv(url.data, \n               col_names = c(names[[\"X1\"]], \"spam_cat\"), \n               trim_ws = TRUE) %>% suppressWarnings()\n\nglimpse(df)\n```\n\nThere are 58 column, the last column 'spam_cat' is the target, which is a label classification of spam (1) or not spam (0).\n\n```{r}\ndim(df)\n```\n\nEach variable represents specific words associated with spam and their percentage present in the message.\n\n### The project\n\nObjective: Create a spam detector using AI models. Create a tool that can get any text as input and estimates the probability of that message being classified as spam or not.\n\n\nCase: Company which send a lot of commercial email wants to reduce their emails to be spam. The dataset provided by the company contain some words with percentages and if were classified as spam or not.\n\n### The algorithm\n\nThis is a classification problem, then It has to be used a model which classifies. Random Forest will be it.\n\n## Preparing data for modeling\n\nWe know our objective, then we have to wrangle the data to get there.\n\n-   `tidyverse`: data wrangling and visualization.\n-   `skimr`: create descriptive statistics summary.\n-   `patchwork`: to put graphics side by side.\n-   `randomForest`: to create the model.\n-   `caret`: to create the confusion matrix.\n-   `ROCR`: to plot ROC curve.\n\n```{r}\ndim(df)   # Dataset previously loaded\n```\n```{r}\nglimpse(df)\n```\n\nVariables representing frequencies will maintain the double class, capital* variable will be set to Integer and spam_cat to factor.\n\n```{r}\nvars.int <- c(\"capital_run_length_average\", \n              \"capital_run_length_longest\", \n              \"capital_run_length_total\")\ndf <- df %>%\n  mutate_at(\"spam_cat\", as.factor) %>%\n  mutate_at(vars.int, as.integer)\n\nanyNA(df)\n```\n\nThere are no missing values NA, then we can proceed with descriptive statistics using skim().\n\n```{r}\n# Disable scientific notion\noptions( scipen = 999, digits = 4 )\n\nskim(df)\n```\n\n-   Most of the p50 and p75 values are close to 0, meanwhile the mean is higher. Suggests a high right tail on the data.\n-   There are 1813 spam emails (39.4%)\n-   High Standard deviation suggests outliers and spread data.\n\n## Exploring the data with visuals\n\n\n```{r}\nfor (var in colnames(select_if(df[,1:47], is.numeric) ) ) {\n    hist( unlist( df[,var]), col = \"blue\",\n          main = paste(\"Histogram of\", var),\n          xlab = var)\n}\n```\n\nTo use ggplot2 we need that dataset in tidy format, to do that we must convert this wide format to long format with the columns *spam* for 'spam_cat', *word* for every column name, and *freq* for the values.\n\n```{r}\ndf.long <- df %>%\n    pivot_longer( cols = 1:57, names_to = \"words\", values_to = \"pct\")\nhead(df.long, 9)\n```\n\nNow its ready for plotting with ggplot2, then we can create boxplots. Boxplot are useful to see the outliers that can distort our classifier (Random Forest), also which words appear more frequently which impact the classification. We can filter only the 'word_' from words column and `spam==1`.\n\n```{r fig.height=14, fig.width=7}\ndf.long %>%\n    filter( str_detect(words, \"word_\") & spam_cat == 1) %>%\n    ggplot() +\n        geom_boxplot( aes( y = reorder(words, pct), x = pct, fill = spam_cat ) ) +\n        labs( title = \"Percentages of words and their association with spam emails\",\n              subtitle = \"The frequency of appearance of some words in emails is more associated with spam\",\n              x = \"Percentage\",\n              y = \"Word\" ) +\n        theme_classic() +\n        theme( plot.subtitle = element_text( color = \"darkgray\", size = 10 ),\n               legend.position = \"none\")\n```\n\nAfter the 24th record all the boxplots have their medians too close to zero, so they do not impact the spam classification too much. Then we know that the top 23 words can have more impact so we have to compare spam and not spam in this words to see how they impact the entire data.\n\n```{r}\ntemp <- df.long %>% \n    filter( str_detect(words, \"word_\") & spam_cat == 1) %>%\n    group_by(words) %>% \n    summarise( pct_sum = sum(pct) ) %>%\n    arrange( desc(pct_sum) )\n\ntop.words <- c(temp$words[1:23], \"spam_cat\")\nremove(temp)\n```\n\nIn this next code we generate a boxplot comparing spam and not spam only on the selected top words. It can be seen as a focus to see more easily the differences.\n\n```{r}\ndf.top <- df %>%\n    select( all_of(top.words) ) %>%\n    mutate( top_words_pct = rowSums( across( where(is.numeric) ) ) )\n\ng1 <- ggplot(df.top) + \n    geom_boxplot( aes( y = factor(spam_cat), x = top_words_pct),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How the presence of words associated with spam emails \n          impacts the classification (TOP23)\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those words.\") +\n    theme_classic()\n```\n\nIn the same way with this second boxplot we compare spam and not spam but with all the words.\n\n```{r}\ndf.2 <- df %>%\n    mutate(word_pct = rowSums( across( where(is.numeric) ) ) )\n\ng2 <- ggplot(df.2) +\n    geom_boxplot( aes( y = factor(spam_cat), x = word_pct ),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How spam associated words impacts the classification\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those words.\") +\n    theme_classic()\n```\n\n```{r fig.width=10}\n# Patchwork library, putting the objects into a parenthesis with a pipe\n\n(g1 | g2)\n```\n\nIt can be seen a large median of those words dissociated with spam emails. To be sure that difference is statistically significant we can perform Kolmogorov-Smirnov test which compare distributions, or U-Mann Whitney which compare medians.\n\n```{r}\npos.spam <- df.top[df.top[\"spam_cat\"] == 1,][[\"top_words_pct\"]]\nneg.spam <- df.top[df.top[\"spam_cat\"] == 0,][[\"top_words_pct\"]]\n\nks.test(pos.spam, neg.spam)\nwilx <- wilcox.test(pos.spam, neg.spam)\nwilx\n# Size effect formula by Wendt\nrbis <- sum(-1, (2 * wilx$statistic) / (length(pos.spam) * length(neg.spam)) )\ncat(\"U Mann Whitney effect size r = \", rbis)\n\n```\n\nBoth test show p < 0.05 thus both groups have different distribution and median according to KS-test and U Mann Whitney test respectively. Also, the size effect Biserial-Rank correlation of U Mann-Whitney is big meaning there are a significance difference between the groups. The spam group values tend to be considerably bigger than no-spam group. Then, the variable spam have a high impact in the difference of the groups.\n\nSince we know the words impact now we can test the characters in a similar way:\n\n```{r}\ndf.long %>%\n    filter( str_detect(words, \"char_\") & spam_cat == 1) %>%\n    ggplot() +\n        geom_boxplot( aes( y = reorder(words, pct), x = pct, fill = spam_cat ) ) +\n        labs( title = \"Percentages of special characters and their association with spam emails\",\n              subtitle = \"The frequency of appearance of some characters in emails is more associated with spam\",\n              x = \"Percentage\",\n              y = \"Character\" ) +\n        theme_classic() +\n        theme( plot.subtitle = element_text( color = \"darkgray\", size = 10 ),\n               legend.position = \"none\")\n```\n\n```{r}\ndf.char <- df %>%\n    select_if(str_detect(colnames(df), pattern = \"char_|^spam_cat\")) %>%\n    mutate( char_pct = rowSums( across( where(is.numeric) ) ) )\n\ng3 <- ggplot(df.char) + \n    geom_boxplot( aes( y = factor(spam_cat), x = char_pct),\n                  fill = c(\"turquoise\", \"coral\") ) +\n    labs( title = \"How the presence of characters associated with spam emails \n          impacts the classification\",\n          subtitle = \"The spam emails(1) have a ghigher percentage of those characters.\") +\n    theme_classic()\n\ng3\n```\n\n```{r}\ndf.char.zero <- df.char %>% filter(spam_cat == 0)\ndf.char.one <- df.char %>% filter(spam_cat == 1)\n\nfor (var in colnames(df.char.zero[,1:6])) {\n    wilx <- wilcox.test(df.char.zero[[var]], df.char.one[[var]])\n    rbis <- abs(sum(-1, (2 * wilx$statistic) / (length(pos.spam) * length(neg.spam)) ))\n    cat(\"\\nMann-Whitney U between spam and not spam on:\", var, \n        \"\\np-value:\", sprintf(\"%6.4f\", wilx$p.value),\n        \"\\nr:\", rbis)\n}\n```\n\n```{r fig.height=6, fig.width=8}\ng4 <- df.char.zero %>% \n    pivot_longer(cols = 1:6, names_to = \"chars\", values_to = \"pct\") %>%\n    ggplot() +\n    geom_boxplot( aes( y = chars, x = pct) ) +\n    labs( y = \"Characters in not spam emails\",\n          x = \"\") +\n    theme_classic()\n\ng5 <- df.char.one %>% \n    pivot_longer(cols = 1:6, names_to = \"chars\", values_to = \"pct\") %>%\n    ggplot() +\n    geom_boxplot( aes( y = chars, x = pct) ) +\n    labs( x = \"Frequencies\",\n          y = \"Characters in spam emails\") +\n    theme_classic()\n\n(g4 / g5)\n```\n\n\nAt this point we know that the number of symbols, and words are statistically different for each group in our classification.\n\n## Selecting the best variables\n\nWhen we checked the variables with boxplots and test comparisons we show how them impact the classifications the most. We should use those variables that have the highest difference between both groups so that it's easier for the algorithm to find a clearer separations between the two groups. The conclusion we show is that 23 words maximize the difference as well as uppercase and the presence of too many symbols.\n\nWe are prepare to create a dataset for modeling. Taking the original dataframe, binding top_words_pct, the target variable, the character and uppercase variables:\n\n```{r}\ndf.model <- df %>%\n    bind_cols( top_words_pct = df.top$top_words_pct ) %>%\n    select( spam_cat, top_words_pct, \n            `char_freq_!`, `char_freq_(`, `char_freq_$`,\n            capital_run_length_total, capital_run_length_longest ) %>%\n    mutate(spam_cat = ifelse(spam_cat == 1, \"is_spam\", \"no_spam\")) %>%\n    mutate_at(vars(spam_cat), as.factor)\n\n\ncolnames(df.model)[3:5] <- c(\"char_freq_exclam\", \"char_freq_paren\", \"char_freq_dollar\")\nslice_sample(df.model, n = 9)\n```\n\n## Modeling\n\n### Training\n\nIn the last code we just replace 1 with 'is_spam' and 0 with 'no_spam'. This is necessary for random forest in this case to classify.\n\n```r\n# Alternative code to replace values:\ndf.model <- df.model %>%\n    mutate( spam_cat = recode(spam_cat, '1'=\"is_spam\", '0'=\"no_spam\") )\n```\n\n-   train: subset used to present the model with the patterns and the labels associated with it so that it can study how to classify each observation according to the patterns that occur.\n-   test: subset where new data is presented to the trained model so that we can measure how accurate it is or how much it has learned.\n\nThe dataset have aprox 60-40 as not-spam and spam respectively. In this case, we won't apply any category balancing technique, this imbalance will not affect the result.\n\n**In R there is no function for splitting the dataset into train and test**\n\nWe are going to use 80% for training and 20% for testing.\n\n```{r}\nn.rows <- nrow(df.model)\nidx <- sample(1:n.rows, size = 0.8 * n.rows)\n\ntrain.80 <- df.model[idx,]\ntest.20 <- df.model[-idx,]\n```\n\nNow we can check if the proportions are similar to the original dataset:\n\n```{r}\nwriteLines(\"Original set:\")\nprop.table( table(df$spam_cat) )\nwriteLines(\"==================\")\nwriteLines(\"Train set:\")\nprop.table( table(train.80$spam_cat) )\nwriteLines(\"==================\")\nwriteLines(\"Test set:\")\nprop.table( table(test.20$spam_cat) )\n```\n\n-   `randomForest()` It must be passed the target variable with `~ .` meaning the target will be explained by the rest of the data represented with '`.`'\n    -   `data=` the data set to use, will be the training set.\n    -   `importance=` if TRUE it will calculate the importance of the variables.\n    -   `ntree=` the number of decision trees to create with this model.\n    \n```{r}\nmodel.rf <- randomForest( spam_cat ~ ., data = train.80,\n                          importance = TRUE,\n                          ntree = 250)\n```\n```{r}\nplot(model.rf)\n```\n\nThis plot shows the performance of the model. After the 50th tree, the error stabilizes.\n\n-   `varImpPlot()`: to plot the feature's importance or which variables are more importance to the model.\n\n```{r fig.width=8}\nvarImpPlot(model.rf)\n```\n\nThis plot shows the importance of each variable.\n\n-   Mean Decrease Accuracy: it calculates how much the model's accuracy decreases when the values of a particular feature are randomly shuffled. A higher value indicates that a feature is more important for the model's accuracy. Then the model relies heavily on that features to make accurate predictions.\n-   Mean Decrease Gini: A higher value indicates that a feature is more important for the model's ability to separate the classes. Features with high MeanDecreaseGini values are those that are useful for creating decision boundaries in the model.\n\nFor the library `randomForest` the default for classification models is the Gini index.\n\n### Testing and evaluating the model\n\nThe most used metrics to evaluate a classification model are *accuracy, confusion matrix, and ROC curve*. \n-   `predict()`: to generate a prediction given as arguments the model and the test set. The object assigned can be used to extract information.\n\n-   `confusionMatrix()`: given a prediction and the target column from the test set shows the information of that prediction.\n\n```{r}\n# Prediction:\nmodel.preds <- predict(model.rf, test.20)\n\nconfusionMatrix(model.preds, test.20$spam_cat, positive = \"no_spam\")\n```\n\nThe confusion matrix show how were the prediction. For 'is_spam' predicted value are 315 'is_spam' as reference, then this 315 are True Positive. The next value is for the predicted 'is_spam' and 'no_spam' as reference with 38 matches, corresponding False Positive known as Type 1 Error. The next two values are False Negative (Type 2 Error) and True Negative with 52 and 516 matches respectively.\n\nThe accuracy is 0.9 aprox, then out of the 100 predictions, there will be around 10 errors with a confidence interval about 12 to 8 errors.\n\n-   **Accuracy**: How many of the total number of classifications the model predicted correctly. Is an overall sense of the model's performance.\n-   **Sensitivity** and **Specificity**: provide insights into the model's performance on the positive and negative classes, respectively. In many cases, depending on the problem, one metric or the other will be more important. (e.g. Medicine, the true positive rate might be more critical then we'll look sensitivity.)\n-   **Kappa**: by accounting for chance agreement helps us to understand the model's performance. A high kappa indicates a strong agreement between the predicted and actual labels.\n-   **Balanced Accuracy**: useful when the labels are unbalanced. It provides a balanced measure of the model's performance.\n\nThe relatively high accuracy (0.902) and a strong kappa value (0.795), it suggests that the model is performing well overall. The sensitivity (0.858) and specificity (0.931) values indicate that the model detect both positive and negative instances quite well.\n\nNow it's time to look at ROC curve to check the performance based on the rate of true positive and false positives (Sensitivity and Specificity).\n\n-   `prediction()` given the data frame with probability predictions with the positive class ('no_spam' according to confusionMatrix) and the real labels which is the test set selecting the target.\n-   `performance()` given the object with `prediction()` and the labels for the axes which are 'tpr' and 'fpr' for true positive rate and false positive rate.\n-   `abline()` for the visualization will draw a diagonal that separates the graphic 50/50\n\n```{r}\nmodel.df.preds <- data.frame( predict(model.rf, test.20, type='prob') )\n\nmodel.roc <- prediction(model.df.preds$no_spam, test.20$spam_cat)\n\nroc <- performance(model.roc, 'tpr', 'fpr')\nauc <- performance(model.roc, \"auc\")\nplot(roc, colorize = T, lwd = 2,\n     main = \"ROC curve. 'no_spam' as positive class.\",\n     sub = paste( \"AUC =\", auc@y.values[[1]]) )\nabline(0.0, 1.0)\n```\n\nAt the bottom we can see the Area Under the Receiver Operating Characteristic Curve (AUC-ROC). If `AUC=1` represents a perfect classifier meanwhile `AUC=0.5` is a random classifier. In this case is a pretty good classier, this value indicates the performance of the classifier.\n\n### Predicting\n\nAfter evaluating, it's time to test the model. \n\nThe input to predict must to be in the very same format as the data frame used in the Random Forest. Then, if we did any transformations this have to be repeated before we can input the new data.\n\nTo do that, we can create a custom function with the steps of preparation and modeling that we took until create 'df.model'. To that custom function we pass whatever we want to predict depending the objective (spam in this case, then we pass a mail) and the function will perform every step to model the data.\n\nThe next function called `prepare_input()` is from this book's code, which takes a string of text and the spam_words vector as input. Then, it reads the text and it will count the selected columns we modeled before, such as !, $, (), uppercase letters, the longest sequence of uppercase, and words in the spam list. Finally, returning a data frame for input in the model we create.\n\n```{r echo=FALSE}\n# Creating a function to prepare any text for input in the model\nprepare_input <- function (text, spam_words){\n  \"This function takes a string text as input, counts the quantities of !, $, (), uppercase letters, longest sequence of uppercase, words in the spam list.\n  * Input: string\n  * Returns: data frame for input in the RF model\"\n  \n  # Counts of the punctuation\n  exclamation <- str_count(text, pattern=\"[!]\")\n  parenthesis <-  str_count(text, pattern=\"[()]\")\n  dollar_sign <-  str_count(text, pattern=\"[$]\")\n  \n  # Counts of UPPERCASE\n  total_uppercase <- str_count(text, \"[A-Z]\")\n  \n  # Remove punctuation for total words count\n  text_no_puncuation <- str_remove_all(text, pattern=\"[:punct:]|[$]*\")\n  \n  #longest_uppercase\n  all_words <- str_split(text_no_puncuation, \" \")\n  all_words <- all_words[[1]]\n  \n  # Create a vector with all the uppercase counts\n  char_counts <- c()\n  for (word in all_words) {\n    if (word == toupper(word)) {\n      char_counts <- c(char_counts, nchar(word))\n    } #enf if\n  }#end for\n  \n  # Get only the longest uppercase word size\n  if (max(char_counts) < 0) {\n    longest_upper <- 0} else {longest_upper <- max(char_counts)}\n  \n  \n  # Count how many spam words are in the text\n  # Create a counter of spam words\n  top_w <- 0\n  # For each word\n  for (word in all_words) {\n    # if word is in the spam list, count +1\n    if (tolower(word) %in% spam_words) {\n      top_w <- top_w + 1\n    } #enf if\n  }#end for\n  \n  # Determine length of the text\n  text_length <- length(all_words)\n  \n  # Create a data frame with all counts in percentages (divided by the text length)\n  input <- data.frame(top_words_pct= 100*top_w / text_length,\n                      char_freq_exclam= 100*exclamation / text_length,\n                      char_freq_paren= 100*parenthesis / text_length,\n                      char_freq_dollar= 100*dollar_sign / text_length,\n                      capital_run_length_total= total_uppercase,\n                      capital_run_length_longest= longest_upper )\n  \nreturn(input)\n} #end function\n\n```\n\nThe next objects will be the emails to check and the spam_words to use:\n\n```{r}\n\ntext1 <- 'SALE!! SALE!! SALE!! SUPER SALEEEE!! This is one of the best sales of the year! More than #3000# products with discounts up to $500 off!! Visit our page and Save $$$ now! Order your product NOW (here) and get one for free !'\n\ntext2 <- 'DEAR MR. JOHN, You will find enclosed the file we talked about during your meeting earlier today. The attachment received here is also available in our web site at this address: www.DUMMYSITE.com. Sale.'\n\nspam.words <- c('you', 'your', 'will', 'free', 'our', 'all', 'mail', 'email', 'business', 'remove', '000', 'font', 'money', 'internet', 'credit', 'over', 'order', '3d', 'address', 'make', 'people', 're', 'receive', 'sale')\n```\n\nIt is time to predict: \n\n```{r}\ninput <- prepare_input(text1, spam.words)\n\ndata.frame( predict(model.rf, input, type = \"prob\") )\n```\n```{r}\ninput <- prepare_input(text2, spam.words)\n\ndata.frame( predict(model.rf, input, type = \"prob\") )\n```\n\nWe can see in this case that spam email (text1) is with 70% probability spam, although text2 which is no spam the model tell us is with 0.51% no spam. Looking the text2 there are some uppercase letters which can fool the model a little bit.\n\nThe next step is save this model and be ready for deployment. To save the model we can use `saveRDS()` function and input the model's name and the name of the output filename. Later with Shiny application we can deploy the model to do it's job (receiving emails from a user or whatever).\n\n```{r}\nsaveRDS(model.rf, \"../scripts/model_rf_spam.rds\")\n```\n\n## Useful Links\n\n-   Mode deep in Supervised and Unsupervised learning, with evaluation measures: https://www.geeksforgeeks.org/supervised-unsupervised-learning/\n\n\n\n# Build an Application with Shiny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"14_modeling2deploy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","bibliography":["../../references.bib"],"editor":"visual","tabset":true,"theme":{"light":["cosmo","../../style/style.scss"],"dark":["cosmo","../../style/dark.scss"]},"title":"Modeling to Deploy"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"14_modeling2deploy.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["../../references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Modeling to Deploy"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}