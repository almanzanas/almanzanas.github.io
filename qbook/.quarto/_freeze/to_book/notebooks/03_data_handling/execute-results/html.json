{
  "hash": "b7cce33c974e1e2b7171fd981fe1b9bb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Handling\"\n---\n\n\nData cleaning project have four parts:\n\n1.  Acquiring and reading the data\n2.  Cleaning the data\n3.  Combining the data\n4.  Preparing the data for analysis\n\n# Acquiring and Reading Data\n\nWe can receive data from different sources and formats such as text, XML, JSON, spreadsheet... And our provider can send us the data trying to be helpful by summarized data, deleting or filling records.\n\nTo be sure, get as much data as possible, at as detailed a level as possible.\n\nOnce we have the data, we have to read it into R as a data frame. Here starts the cleaning process, identifying missing values, column classes and names. Also to create a *key* field as unique identifier.\n\n# Cleaning Data\n\nBefore any changes, how the data looks like:\n\n1.  Tabulate the keys looking for duplicates. \n    -   If there are duplicate keys, we can search for duplicated records. We may delete them and record what we did.\n    -   If only the key is duplicated, we have to evaluate the observation.\n2.  Check column type and missing values per column. Could be useful create an histogram or summary statistics on the missing values.\n    -   When some columns have the same number of missing values on the same observations could be because those observations failed to match the data source when was constructed.\n    -   Numeric columns: the mean and range will be important.\n    -   Columns supposed to be integer or character we can check unique values to check if its what we expected.\n    -   Date columns: min and max could be important. Also tabulate dates by month or quarter looking for anomalous conditions (months without observations).\n3.  We found missing values or errors.\n    -   It is possible to return the data to the provider, point the issues to verify whether or not is the correct data.\n    -   For missing values, we could delete the observation but should be a rare tactic. If we have a large amount of missing values we can *impute* this values (replace NA with other valid value).\n    -   If we have two data sets of the same data we can confront the data on one column to check the quality of the data. Also, before merging, we will need to have the adequate values in some columns such as sex (0 or 1, F or M, True or False) being consistent.\n\n# Combining Data\n\n## Combining by Row\n\nSometimes we need to combine datasets with the same type of observations from diferent sources. They have to have:\n\n-   Same column names. Exactly.\n-   Same column classes.\n-   Match categorical values.\n-   Examine the key column to ensure that will be unique after combine. If not, construct a new one.\n-   Create a new column specifying the source (original dataset).\n\nAs an example, lets compare three datasets. First, the number of columns. And second, the names ordered.\n\n```r\n# Number of columns, we expect only one number:\nlength ( unique( c(ncol(MAD), ncol(BCN), ncol(BIL)) ) )\n\n# Compare pairs of datasets on column names, we expect TRUE:\nall ( sort(names(MAD)) ) == all ( sort(names(BCN)) )\nall ( sort(names(MAD)) ) == all ( sort(names(BIL)) )\n```\n\nNext, we compare the column classes with `all.equal()` which is necessary for lists.\n\n```r\n# Compare pair of classes expecting TRUE\nall.equal ( sapply(MAD, class),\n            sapply(BCN, class)[names(MAD)] )\nall.equal ( sapply(MAD, class),\n            sapply(BIL, class)[names(MAD)] )\n\n# If class returns a vector length 2 (like POSIX date objects)\n# we have to use a custom function:\nall.equal ( sapply(MAD, function(x) class(x)[1])\n            sapply(BCN, function(x) class(x)[1])[names(MAD)] )\n```\n\nTo verify the categorical (factor) variables we are going to convert the factor class into characters for compare their values.\n\n```r\n# Getting column names for columns with character or factor class\ncats <- names(MAD)[ sapply (MAD, class) == \"character\" ||\n                    sapply (MAD, class) == \"factor\" ]\n\n# Extracting the unique values for these columns on each dataset\nlevs.mad <- lapply ( MAD[,cats],\n                     function(x) unique (sort (as.character (x))) )\nlevs.bcn <- lapply ( BCN[,cats],\n                     function(x) unique (sort (as.character (x))) )                  \nlevs.bil <- lapply ( BIL[,cats],\n                     function(x) unique (sort (as.character (x))) )\n\n# Compare the extracted values expecting TRUE\nall.equal ( levs.mad, levs.bcn ) && all.equal ( levs.mad, levs.bil )\n```\n\nThe last thing to do it is create a column with the source before combining:\n\n```r\nMAD$Source <- \"MAD\"\nBCN$Source <- \"BCN\"\nBIL$Source <- \"BIL\"\ncities <- rbind (MAD, BCN, BIL, stringsAsFactors=FALSE)\n```\n\n## Combining by Column\n\nFor data frames with the same number of rows using `data.frame()` function we can combine them and the function will distinct the column names to be unique.\n\n## Merging by key\n\nWhen the observations of both data frames have different orders we will use `merge()` function.\n\n-   The return of `merge()` is sorted according to *key* column.\n-   With duplicated name columns it will change to a unique name (col.x and col.y). It is better before merging to rename that columns in both data frames.\n\n# Transactional Data\n\nTabular data is one row per key, but transactional data may have multiple rows for each key, one row per transaction. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey <- data.frame(\n  ID = c(\"AA\", \"AA\", \"CC\", \"CC\", \"CC\", \"DD\", \"EE\"),\n  Date = as.Date(c(\"2012-09-26\", \"2014-01-16\", \"2013-03-13\", \"2014-04-30\",\n                   \"2015-03-31\", \"2013-06-03\", \"2013-12-02\")),\n  Response = c(3, 4, 3, 5, 4, 2, 4)\n)\nsurvey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID       Date Response\n1 AA 2012-09-26        3\n2 AA 2014-01-16        4\n3 CC 2013-03-13        3\n4 CC 2014-04-30        5\n5 CC 2015-03-31        4\n6 DD 2013-06-03        2\n7 EE 2013-12-02        4\n```\n\n\n:::\n:::\n\n\nThe previous data frame could be considered tabular if our interest is in each transaction but it is considered transactional data because our interest is in each unique ID.\n\nEasily we can get the mean of 'Response' by each ID:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith (survey, tapply(Response, ID, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n AA  CC  DD  EE \n3.5 4.0 2.0 4.0 \n```\n\n\n:::\n:::\n\n\nBut it is more interesting to get other data frame with one ID per row. Also we can add how many entries have each ID, the first date, and other variables of interest.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrle.survey <- rle ( sort(survey$ID) )\nrle.survey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:4] 2 3 1 1\n  values : chr [1:4] \"AA\" \"CC\" \"DD\" \"EE\"\n```\n\n\n:::\n:::\n\n\n# Preparing Data\n\nHere we can create new columns for make modeling easier. For example, binning columns which is create a column from numeric to vector. Also creating a new and small set of categorical levels from an existing one which will be helpful to have a cross-reference table that connects both. \n\n# Documentation\n\nThe 'data dictionary' is the documentation provided to you with the data. Should contain the files, names of each column and possible values.\n\nOther documentation will be generated by us describing what we did in the process of data cleaning. The minimum is to write comments into the R scripts explaining what it do. More often we will write a report for the handling task with the steps and decisions over the observations. \n\nIt is recommended to have a master table with every key and its disposition. It is useful to identify quickly the outcome associated with every record. Could contain \"no payment information\", \"illegal RCODE\"...\n\nThe most important goal of the documentation is to do our work 'reproducible'.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}