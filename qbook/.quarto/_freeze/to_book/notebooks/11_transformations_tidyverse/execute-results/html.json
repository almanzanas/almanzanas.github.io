{
  "hash": "bcb424ef8b1bfbd6286ab4b0c2e6fbb6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Transformations with Tidyverse\"\n---\n\n\nDataset: https://archive.ics.uci.edu/ml/datasets/Adult\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages('tidyverse')\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\nTidy data is one observation per row, one measurement or variable per column and one value per cell.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheader <- c(\"age\", \"workclass\", \"fnlwgt\",\"education\",\n\"education_num\", \"marital_status\", \"occupation\",\n\"relationship\", \"race\", \"sex\", \"capital_gain\", \"capital_loss\",\"hours_per_week\", \"native_country\", \"target\")\n\ndf <- read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", col_names = header, \n                   trim_ws = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 32561 Columns: 15\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (9): workclass, education, marital_status, occupation, relationship, rac...\ndbl (6): age, fnlwgt, education_num, capital_gain, capital_loss, hours_per_week\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 15\n    age workclass       fnlwgt education education_num marital_status occupation\n  <dbl> <chr>            <dbl> <chr>             <dbl> <chr>          <chr>     \n1    39 State-gov        77516 Bachelors            13 Never-married  Adm-cleri…\n2    50 Self-emp-not-i…  83311 Bachelors            13 Married-civ-s… Exec-mana…\n3    38 Private         215646 HS-grad               9 Divorced       Handlers-…\n4    53 Private         234721 11th                  7 Married-civ-s… Handlers-…\n5    28 Private         338409 Bachelors            13 Married-civ-s… Prof-spec…\n6    37 Private         284582 Masters              14 Married-civ-s… Exec-mana…\n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n\n# Slicing and filtering\n\nThe basic form of dplyr for slicing it to use a `.` to consider everything from the object that precedes it. The returned object will be a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% .[1:4, c(2:5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  workclass        fnlwgt education education_num\n  <chr>             <dbl> <chr>             <dbl>\n1 State-gov         77516 Bachelors            13\n2 Self-emp-not-inc  83311 Bachelors            13\n3 Private          215646 HS-grad               9\n4 Private          234721 11th                  7\n```\n\n\n:::\n:::\n\n\n-   `slice_min(), slice_max()`: to fetch the top or bottom observation given a percentage.\n-   `slice_sample()`: to extract a sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% slice_min(age, prop = 0.15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,570 × 15\n     age workclass fnlwgt education education_num marital_status occupation     \n   <dbl> <chr>      <dbl> <chr>             <dbl> <chr>          <chr>          \n 1    17 ?         304873 10th                  6 Never-married  ?              \n 2    17 Private    65368 11th                  7 Never-married  Sales          \n 3    17 Private   245918 11th                  7 Never-married  Other-service  \n 4    17 Private   191260 9th                   5 Never-married  Other-service  \n 5    17 Private   270942 5th-6th               3 Never-married  Other-service  \n 6    17 Private    89821 11th                  7 Never-married  Other-service  \n 7    17 Private   175024 11th                  7 Never-married  Handlers-clean…\n 8    17 ?         202521 11th                  7 Never-married  ?              \n 9    17 ?         258872 11th                  7 Never-married  ?              \n10    17 Private   211870 9th                   5 Never-married  Other-service  \n# ℹ 5,560 more rows\n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% slice_sample(n=10, replace = FALSE) %>% .[,1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n     age workclass    fnlwgt education   \n   <dbl> <chr>         <dbl> <chr>       \n 1    44 Federal-gov  280362 Assoc-acdm  \n 2    27 Private      172009 Bachelors   \n 3    59 Private      157932 10th        \n 4    51 Federal-gov  217647 Some-college\n 5    32 Private      185027 Some-college\n 6    50 Private      237868 Masters     \n 7    33 Private      121488 Bachelors   \n 8    36 Private      127306 Bachelors   \n 9    19 Private      298891 11th        \n10    51 Self-emp-inc 100029 Doctorate   \n```\n\n\n:::\n:::\n\n\n## Filtering\n\n-   `filter()`: returns rows given a condition.\n-   `select()`: to choose variable to show in the given order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  filter( age < 30 ) %>%\n  select( marital_status, age, education ) %>%\n  slice_sample( n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   marital_status       age education   \n   <chr>              <dbl> <chr>       \n 1 Never-married         29 HS-grad     \n 2 Never-married         25 HS-grad     \n 3 Never-married         21 9th         \n 4 Never-married         23 Bachelors   \n 5 Never-married         20 Some-college\n 6 Married-civ-spouse    28 HS-grad     \n 7 Never-married         19 HS-grad     \n 8 Never-married         21 Some-college\n 9 Divorced              29 HS-grad     \n10 Never-married         19 Some-college\n```\n\n\n:::\n:::\n\n\n- distinct(): to extract unique values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% distinct(sex) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 1\n  sex   \n  <chr> \n1 Male  \n2 Female\n```\n\n\n:::\n:::\n\n\n# Grouping and summarizing data\n\nThe next functions are complementary, usually used together.\n\n-   `group_by()`: to group a variable by its values\n-   `summarize()`: given a function with a variable returns the result.\n-   `ungroup()`: after `group_by()` with more than one variable, it returns a `tbl_df`. The ungrouped tibble requires less memory space than the tibble one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% group_by(workclass) %>% .[1:10,1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n# Groups:   workclass [3]\n     age workclass        fnlwgt education\n   <dbl> <chr>             <dbl> <chr>    \n 1    39 State-gov         77516 Bachelors\n 2    50 Self-emp-not-inc  83311 Bachelors\n 3    38 Private          215646 HS-grad  \n 4    53 Private          234721 11th     \n 5    28 Private          338409 Bachelors\n 6    37 Private          284582 Masters  \n 7    49 Private          160187 9th      \n 8    52 Self-emp-not-inc 209642 HS-grad  \n 9    31 Private           45781 Masters  \n10    42 Private          159449 Bachelors\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% group_by(sex) %>% summarise( avg_age = mean(age), sd_age = sd(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  sex    avg_age sd_age\n  <chr>    <dbl>  <dbl>\n1 Female    36.9   14.0\n2 Male      39.4   13.4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmarital.groups <- df %>% group_by(marital_status, sex) %>%\n  summarize( avg_age = mean(age) )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'marital_status'. You can override using\nthe `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nmarital.groups\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 3\n# Groups:   marital_status [7]\n   marital_status        sex    avg_age\n   <chr>                 <chr>    <dbl>\n 1 Divorced              Female    43.3\n 2 Divorced              Male      42.7\n 3 Married-AF-spouse     Female    33.1\n 4 Married-AF-spouse     Male      31.4\n 5 Married-civ-spouse    Female    39.5\n 6 Married-civ-spouse    Male      43.7\n 7 Married-spouse-absent Female    39.6\n 8 Married-spouse-absent Male      41.6\n 9 Never-married         Female    28.1\n10 Never-married         Male      28.2\n11 Separated             Female    39.6\n12 Separated             Male      39.0\n13 Widowed               Female    58.4\n14 Widowed               Male      61.7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nungroup(marital.groups)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 3\n   marital_status        sex    avg_age\n   <chr>                 <chr>    <dbl>\n 1 Divorced              Female    43.3\n 2 Divorced              Male      42.7\n 3 Married-AF-spouse     Female    33.1\n 4 Married-AF-spouse     Male      31.4\n 5 Married-civ-spouse    Female    39.5\n 6 Married-civ-spouse    Male      43.7\n 7 Married-spouse-absent Female    39.6\n 8 Married-spouse-absent Male      41.6\n 9 Never-married         Female    28.1\n10 Never-married         Male      28.2\n11 Separated             Female    39.6\n12 Separated             Male      39.0\n13 Widowed               Female    58.4\n14 Widowed               Male      61.7\n```\n\n\n:::\n:::\n\n\n-   `quantile()`: returns the number corresponding the passing percentage.\n-   `first()`: returns the first number. Combined with `group_by()` returns the first number of each group.\n-   `across()`: applies a function to the selected columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% group_by(marital_status) %>% summarise(first(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  marital_status        `first(age)`\n  <chr>                        <dbl>\n1 Divorced                        38\n2 Married-AF-spouse               19\n3 Married-civ-spouse              50\n4 Married-spouse-absent           49\n5 Never-married                   39\n6 Separated                       54\n7 Widowed                         36\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% group_by(sex) %>% summarise( \"50%\" = quantile(age, 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  sex    `50%`\n  <chr>  <dbl>\n1 Female    35\n2 Male      38\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% select(1,3,5,11,12,13) %>%\n  summarise( across(everything(), mean) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n    age  fnlwgt education_num capital_gain capital_loss hours_per_week\n  <dbl>   <dbl>         <dbl>        <dbl>        <dbl>          <dbl>\n1  38.6 189778.          10.1        1078.         87.3           40.4\n```\n\n\n:::\n:::\n\n\n# Replacing and Filling Data\n\nA dataset will be imperfect, in this case we have '?' instead of NA. First, the character '?' has to be replaced with NA and then we can replace NA with other character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (var in colnames(df) ) {\n    print(\n        paste (var, nrow( df[df[var] == '?', ] ) )\n    )\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"age 0\"\n[1] \"workclass 1836\"\n[1] \"fnlwgt 0\"\n[1] \"education 0\"\n[1] \"education_num 0\"\n[1] \"marital_status 0\"\n[1] \"occupation 1843\"\n[1] \"relationship 0\"\n[1] \"race 0\"\n[1] \"sex 0\"\n[1] \"capital_gain 0\"\n[1] \"capital_loss 0\"\n[1] \"hours_per_week 0\"\n[1] \"native_country 583\"\n[1] \"target 0\"\n```\n\n\n:::\n:::\n\n\nIn the output we can see the missing values represented with '?': \"workclass 1836\", \"occupation 1843\", and \"native_country 583\". Now we can use `mutate()` to edit the columns affected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.rep <- df %>%\n    mutate (workclass = replace(workclass, workclass == '?', NA),\n            occupation = replace(occupation, occupation == '?', NA),\n            native_country = replace(native_country, native_country == '?', NA)\n            )\n\nslice_sample( df.rep[which(is.na(df.rep[\"workclass\"])),], n=10 )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 15\n     age workclass fnlwgt education    education_num marital_status   occupation\n   <dbl> <chr>      <dbl> <chr>                <dbl> <chr>            <chr>     \n 1    80 <NA>       91901 HS-grad                  9 Married-civ-spo… <NA>      \n 2    77 <NA>      152900 5th-6th                  3 Married-civ-spo… <NA>      \n 3    22 <NA>      306031 Some-college            10 Never-married    <NA>      \n 4    29 <NA>      168873 Some-college            10 Divorced         <NA>      \n 5    20 <NA>      114813 10th                     6 Separated        <NA>      \n 6    18 <NA>       30246 Some-college            10 Never-married    <NA>      \n 7    20 <NA>      149478 Some-college            10 Never-married    <NA>      \n 8    19 <NA>      220517 Some-college            10 Never-married    <NA>      \n 9    55 <NA>      106707 Assoc-acdm              12 Married-civ-spo… <NA>      \n10    35 <NA>      124836 Some-college            10 Divorced         <NA>      \n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n\nOne alternative can be to use `across(everything())` to replace with `ifelse()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.rep <- df %>% \n      mutate( across( everything(), ~ ifelse( . == '?', NA, . ) ) )\n\ndf.rep[which(is.na(df.rep[\"workclass\"])),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,836 × 15\n     age workclass fnlwgt education    education_num marital_status   occupation\n   <dbl> <chr>      <dbl> <chr>                <dbl> <chr>            <chr>     \n 1    54 <NA>      180211 Some-college            10 Married-civ-spo… <NA>      \n 2    32 <NA>      293936 7th-8th                  4 Married-spouse-… <NA>      \n 3    25 <NA>      200681 Some-college            10 Never-married    <NA>      \n 4    67 <NA>      212759 10th                     6 Married-civ-spo… <NA>      \n 5    17 <NA>      304873 10th                     6 Never-married    <NA>      \n 6    35 <NA>      129305 HS-grad                  9 Married-civ-spo… <NA>      \n 7    43 <NA>      174662 Some-college            10 Divorced         <NA>      \n 8    52 <NA>      252903 HS-grad                  9 Divorced         <NA>      \n 9    68 <NA>       38317 1st-4th                  2 Divorced         <NA>      \n10    53 <NA>      135105 Bachelors               13 Divorced         <NA>      \n# ℹ 1,826 more rows\n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n\nTo handle missing values we can drop them, filling them with the previous or next valid value, or replacing them with a statistic value, such as the mean value.\n\n-   `fill()`: Fills missing values in selected columns using the next or previous entry.\n    -   `.direction=` to choose the direction of the fill (down, up, downup, updown).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.rep.na.ind <- which(is.na(df.rep[\"occupation\"]))\n\ndf.rep %>% fill (workclass, occupation, native_country,\n                 .direction = \"down\") %>%\n    .[df.rep.na.ind,] %>%\n    slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 15\n     age workclass      fnlwgt education education_num marital_status occupation\n   <dbl> <chr>           <dbl> <chr>             <dbl> <chr>          <chr>     \n 1    22 Private        263970 Some-col…            10 Never-married  Other-ser…\n 2    82 Private        403910 HS-grad               9 Never-married  Machine-o…\n 3    19 Private        117201 HS-grad               9 Never-married  Craft-rep…\n 4    61 Private        116230 Bachelors            13 Married-civ-s… Craft-rep…\n 5    21 Self-emp-not-… 207988 HS-grad               9 Married-civ-s… Craft-rep…\n 6    79 Federal-gov    142171 7th-8th               4 Married-civ-s… Adm-cleri…\n 7    63 Local-gov      447079 HS-grad               9 Never-married  Prof-spec…\n 8    22 Private         88126 Some-col…            10 Never-married  Prof-spec…\n 9    71 Private        229424 HS-grad               9 Widowed        Handlers-…\n10    64 Self-emp-inc   338355 Assoc-voc            11 Married-civ-s… Sales     \n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n\nWhen the variable is categorical it is common to replace the missing values with the most common category. \n\n>Every change in a dataset is a decision that the data scientist has to make and <b>it will certainly affect the result</b>\n\nThis is how we can replace NA with the most frequent value on the categorical variables. First we have to found that value using `table()` with `which.max()`. Then we can use that to replace NA with `replace_na()` pointing both columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Most frequent value\nm.f.workcls <- names( table(df$workclass)[which.max(table(df$workclass))])\nm.f.occp <- names( table(df$occupation)[which.max(table(df$occupation))])\n\n# Replacing NA\ndf.no.na <- df.rep %>% replace_na( list( workclass = m.f.workcls,\n                                         occupation = m.f.occp) )\n\nslice_sample( df.no.na[df.rep.na.ind,], n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 15\n     age workclass fnlwgt education    education_num marital_status   occupation\n   <dbl> <chr>      <dbl> <chr>                <dbl> <chr>            <chr>     \n 1    76 Private    84755 Some-college            10 Widowed          Prof-spec…\n 2    58 Private   158506 11th                     7 Married-civ-spo… Prof-spec…\n 3    66 Private   182378 7th-8th                  4 Married-civ-spo… Prof-spec…\n 4    82 Private    42435 10th                     6 Widowed          Prof-spec…\n 5    62 Private   113234 Masters                 14 Married-civ-spo… Prof-spec…\n 6    60 Private    88675 HS-grad                  9 Married-civ-spo… Prof-spec…\n 7    19 Private   230874 Some-college            10 Never-married    Prof-spec…\n 8    69 Private   163595 HS-grad                  9 Widowed          Prof-spec…\n 9    33 Private   202498 7th-8th                  4 Separated        Prof-spec…\n10    60 Private    56248 HS-grad                  9 Married-civ-spo… Prof-spec…\n# ℹ 8 more variables: relationship <chr>, race <chr>, sex <chr>,\n#   capital_gain <dbl>, capital_loss <dbl>, hours_per_week <dbl>,\n#   native_country <chr>, target <chr>\n```\n\n\n:::\n:::\n\n\nAt this point, the data frame only have NA values in native_country. If the NA is less than 5% of the total observation we could drop that observations. With 'workclass' and 'occupation' this percentage was bigger than 5% but on 'native_country' is less than 2%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop NA\ndf.no.na <- df.no.na %>% drop_na()\n```\n:::\n\n\nExample to extract NA percentage:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get proportions with table()\ntable(df.rep$occupation, useNA = 'ifany') %>% prop.table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Adm-clerical      Armed-Forces      Craft-repair   Exec-managerial \n     0.1157826848      0.0002764043      0.1258867971      0.1248733147 \n  Farming-fishing Handlers-cleaners Machine-op-inspct     Other-service \n     0.0305273180      0.0420748749      0.0614845981      0.1011946808 \n  Priv-house-serv    Prof-specialty   Protective-serv             Sales \n     0.0045760265      0.1271459722      0.0199318203      0.1120972943 \n     Tech-support  Transport-moving              <NA> \n     0.0285003532      0.0490464052      0.0566014557 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Basic alternative\npaste(\"NA percentage on 'occupation' variable: \",\n    sum(is.na(df.rep$occupation)) / nrow(df.rep) * 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NA percentage on 'occupation' variable:  5.66014557292466\"\n```\n\n\n:::\n:::\n\n\n# Arranging data\n\n-   `arrange()`: to order a data frame by a column to ascending order\n    -   `desc()`: to change the order to descending\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>% arrange( desc(fnlwgt) ) %>% .[1:10,1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n     age workclass     fnlwgt education   \n   <dbl> <chr>          <dbl> <chr>       \n 1    25 Private      1484705 Some-college\n 2    39 Private      1455435 Assoc-acdm  \n 3    45 Private      1366120 Assoc-voc   \n 4    29 Private      1268339 HS-grad     \n 5    35 Private      1226583 Bachelors   \n 6    30 Private      1184622 Some-college\n 7    33 Private      1161363 Some-college\n 8    42 Local-gov    1125613 HS-grad     \n 9    42 Self-emp-inc 1097453 Bachelors   \n10    24 Private      1085515 HS-grad     \n```\n\n\n:::\n:::\n\n\nAlso can be useful with `group_by()`, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>%\n    group_by(marital_status) %>%\n    summarize( count = n() ,\n               avg_net_gain = mean( capital_gain - capital_loss) ) %>%\n    arrange( desc(avg_net_gain) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  marital_status        count avg_net_gain\n  <chr>                 <int>        <dbl>\n1 Married-civ-spouse    14692        1612.\n2 Divorced               4394         668.\n3 Married-spouse-absent   397         562.\n4 Widowed                 979         495.\n5 Separated              1005         487.\n6 Married-AF-spouse        23         433.\n7 Never-married         10488         328.\n```\n\n\n:::\n:::\n\n\n# Creating new variables\n\nWe can create new variables such as splitting a column, creating a calculation, encoding text, applying a custom function...\n\n-   `separate()`: to split a column into two column, by default remove the original column.\n    -   `remove=` if `FALSE` to keep the original column\n-   `unite()`: is the complementary function to separate(), is useful to create a unique identifier.\n    -   `sep=` to specify the separator of the new column values\n    -   `remove=FALSE` to keep the original column\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>% separate(target, into = c(\"sign\", \"amount\"), sep = \"\\\\b\") %>%\n    slice_sample(n=10) %>% .[,-(3:14)]\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expected 2 pieces. Additional pieces discarded in 31978 rows [1, 2, 3, 4, 5, 6,\n7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...].\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n     age workclass        sign  amount\n   <dbl> <chr>            <chr> <chr> \n 1    21 Private          <=    50K   \n 2    25 Private          <=    50K   \n 3    27 Private          <=    50K   \n 4    34 Federal-gov      >     50K   \n 5    39 Private          <=    50K   \n 6    39 Private          >     50K   \n 7    32 Local-gov        <=    50K   \n 8    19 Private          <=    50K   \n 9    24 Private          <=    50K   \n10    39 Self-emp-not-inc <=    50K   \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>%\n    unite( sex, race, age, col=\"description\", sep=\"_\", remove = FALSE) %>%\n    select(sex, race, age, description, marital_status) %>%\n    slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 5\n   sex    race    age description     marital_status    \n   <chr>  <chr> <dbl> <chr>           <chr>             \n 1 Female White    38 Female_White_38 Divorced          \n 2 Female White    26 Female_White_26 Never-married     \n 3 Male   White    20 Male_White_20   Never-married     \n 4 Male   Black    56 Male_Black_56   Married-civ-spouse\n 5 Male   White    39 Male_White_39   Divorced          \n 6 Female White    23 Female_White_23 Never-married     \n 7 Male   White    47 Male_White_47   Married-civ-spouse\n 8 Male   White    46 Male_White_46   Married-civ-spouse\n 9 Male   White    55 Male_White_55   Married-civ-spouse\n10 Male   White    47 Male_White_47   Married-civ-spouse\n```\n\n\n:::\n:::\n\n\n## The `mutate()` function\n\n-   `mutate()`: designed to create new variables. Also can be used to modified existing variables using the same column name. Given a data frame, then the new variable name equal to the values.\n-   `recode()`: working as a mapping to transform variables\n\nThe new variable which you can create could be whatever are in our mind, a custom function, a simple calculation, a vector...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>%\n    mutate ( total_gain = capital_gain - capital_loss,\n             tax = ifelse( total_gain >= 15000,\n                           total_gain * 0.21,\n                           total_gain * 0.1) ) %>%\n    slice_sample(n=10) %>% select(total_gain, tax, occupation, age) %>%\n    arrange ( desc(tax) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n   total_gain   tax occupation          age\n        <dbl> <dbl> <chr>             <dbl>\n 1       7688  769. Sales                37\n 2          0    0  Machine-op-inspct    45\n 3          0    0  Prof-specialty       37\n 4          0    0  Other-service        51\n 5          0    0  Machine-op-inspct    33\n 6          0    0  Sales                25\n 7          0    0  Prof-specialty       51\n 8          0    0  Other-service        28\n 9          0    0  Prof-specialty       39\n10          0    0  Prof-specialty       22\n```\n\n\n:::\n:::\n\n\nCombining `mutate()` and `recode()` to transform values, useful for categories:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>%\n    mutate( over_under = recode ( target, '<=50'='under', '>50'='over') ) %>%\n    select(target, over_under) %>%\n    slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   target over_under\n   <chr>  <chr>     \n 1 <=50K  <=50K     \n 2 <=50K  <=50K     \n 3 >50K   >50K      \n 4 <=50K  <=50K     \n 5 <=50K  <=50K     \n 6 <=50K  <=50K     \n 7 <=50K  <=50K     \n 8 <=50K  <=50K     \n 9 >50K   >50K      \n10 <=50K  <=50K     \n```\n\n\n:::\n:::\n\n\nFor binning a new variable using `mutate()` in combination with `cut()`. To `cut()` will pass the column, a vector with the intervals, and a vector with the name of that intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.no.na %>%\n    mutate( age_avg = mean(age), \n            over_under_age_avg = cut( age,\n                                      c(0, mean(age), max(age)),\n                                      c('Lower than avg', 'Above the avg'))) %>%\n    select (age, age_avg, over_under_age_avg) %>%\n    slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n     age age_avg over_under_age_avg\n   <dbl>   <dbl> <fct>             \n 1    51    38.6 Above the avg     \n 2    33    38.6 Lower than avg    \n 3    28    38.6 Lower than avg    \n 4    21    38.6 Lower than avg    \n 5    49    38.6 Above the avg     \n 6    28    38.6 Lower than avg    \n 7    31    38.6 Lower than avg    \n 8    26    38.6 Lower than avg    \n 9    23    38.6 Lower than avg    \n10    59    38.6 Above the avg     \n```\n\n\n:::\n:::\n\n\n# Joining datasets\n\n-   `left_join()`\n-   `right_join()`\n    -   `keep=` if `TRUE` cause the equal variables from both tables to repeat.\n    -   `by=` passing a column to join. It could be passed two column which represent the same values, like `by=c('store_id'='id_store')`\n-   `inner_join()`\n-   `full_join()`\n-   `anti_join()`\n\nIf in the previous join functions we don't pass id= argument, it will determine automatically on which column to join.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales <- data.frame(\n  date = c(\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"2022-01-04\", \"2022-01-05\"),\n  store_cd= c(1,2,3,4,5),\n  product_cd= c(1,2,3,4,5),\n  qty= c(10, 12, 9, 12,8), \n  sales= c(30, 60, 45, 24, 32)\n  )\n\nstores <- data.frame(\n  store_cd= c(1,2,3,4,6),\n  address= c('1 main st', '20 side st','19 square blvd','101 first st','1002 retail ave'),\n  city= c('Main', 'East', 'West', 'North', 'South'), \n  open_hours= c('7-23', '7-23', '9-21', '9-21', '9-21')\n  )\n\nproducts <- data.frame(\n  product_cd= c(1,2,3,4,6),\n  description= c('Soft drink', 'Frozen snack', 'Fruit', 'Water', 'Fruit 2'),\n  unit_price= c(3.0, 5.0, 5.0, 2.0, 4.0), \n  unit_measure= c('each', 'each', 'kg', 'each', 'kg')\n  )\n```\n:::\n\n\n#### Left Join\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales %>%\n    left_join (products[,1:2], by='product_cd')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date store_cd product_cd qty sales  description\n1 2022-01-01        1          1  10    30   Soft drink\n2 2022-01-02        2          2  12    60 Frozen snack\n3 2022-01-03        3          3   9    45        Fruit\n4 2022-01-04        4          4  12    24        Water\n5 2022-01-05        5          5   8    32         <NA>\n```\n\n\n:::\n:::\n\n\n#### Right Join\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales %>%\n    select(store_cd, sales) %>%\n    right_join(stores, by = 'store_cd')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  store_cd sales         address  city open_hours\n1        1    30       1 main st  Main       7-23\n2        2    60      20 side st  East       7-23\n3        3    45  19 square blvd  West       9-21\n4        4    24    101 first st North       9-21\n5        6    NA 1002 retail ave South       9-21\n```\n\n\n:::\n:::\n\n\n#### Full Join\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales %>% full_join(stores)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(store_cd)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date store_cd product_cd qty sales         address  city open_hours\n1 2022-01-01        1          1  10    30       1 main st  Main       7-23\n2 2022-01-02        2          2  12    60      20 side st  East       7-23\n3 2022-01-03        3          3   9    45  19 square blvd  West       9-21\n4 2022-01-04        4          4  12    24    101 first st North       9-21\n5 2022-01-05        5          5   8    32            <NA>  <NA>       <NA>\n6       <NA>        6         NA  NA    NA 1002 retail ave South       9-21\n```\n\n\n:::\n:::\n\n\n# Reshaping a table\n\nA data frame in a wide shape is not suitable for machine learning algorithms and for most of the plotting functions. A wide format is when the variable are spread along the rows instead of columns.\n\n-   `pivot_longer()`: given a wide data frame, it will shape it to long format.\n    -   `cols=` to specify which columns should be reshaped, passing a range (`2:6`)\n    -   `names_to=` passing a string as column name for the columns specified in `cols=` argument\n    -   `values_to=` passing a column name for the column representing the values.\n-   `pivot_wider()`: given a long data frame, it will shape it to wide format.\n    -   `names_from=` passing a column name, will take that values to form column names.\n    -   `values_from=` passing a column name, will take that values as values.\n\n# Interesting Tidyverse functions\n\nUsing `data('mtcars')` dataset.\n\nThe `purrr` library contain functions similar to `apply()` family.\n\n-   `map()`: applies the same function to every element of a vector or list.\n\nFrom `dplyr` there are functions similar to `rbind()` and `cbind()`:\n\n-   `bind_rows()`: the data frames must have the same columns\n-   `bind_cols()`: the data frames must have the same number of observations.\n\nFunctions used alongside `mutate()` are cumutalive aggregate functions such as `cumsum(), cumprod(), cummean(), cummax(), cume_dist()`. This functions expect a variable name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('datasets')\ndata('mtcars')\n\nmtcars %>% mutate( cumsum_weight = cumsum(wt),\n                   cumpct_weight = cume_dist(wt),\n                   cummean_weight = cummean(wt) ) %>%\n    select(wt, cumsum_weight, cumpct_weight, cummean_weight) %>%\n    slice_sample(n=10) %>%\n    arrange(cumpct_weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    wt cumsum_weight cumpct_weight cummean_weight\nFiat X1-9        1.935        87.009       0.12500       3.346500\nDatsun 710       2.320         7.815       0.21875       2.605000\nVolvo 142E       2.780       102.952       0.34375       3.217250\nMazda RX4 Wag    2.875         5.495       0.37500       2.747500\nHornet 4 Drive   3.215        11.030       0.50000       2.757500\nAMC Javelin      3.435        77.389       0.53125       3.364739\nDodge Challenger 3.520        73.954       0.68750       3.361545\nDuster 360       3.570        21.500       0.75000       3.071429\nMerc 450SLC      3.780        46.300       0.81250       3.307143\nCamaro Z28       3.840        81.229       0.84375       3.384542\n```\n\n\n:::\n:::\n\n\n-   `case_when()`: also from `dplyr.` to deal with multiple cases of logical tests.\n    -   As argument we pass a condition and what will return if it's `TRUE`, separated by `~`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate( transmission_type = case_when ( am == 0 ~ 'automatic',\n                                            am == 1 ~ 'manual' ) ) %>%\n    select(cyl, mpg, am, transmission_type) %>%\n    slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   cyl  mpg am transmission_type\nChrysler Imperial    8 14.7  0         automatic\nMerc 450SLC          8 15.2  0         automatic\nFiat X1-9            4 27.3  1            manual\nMerc 280C            6 17.8  0         automatic\nCadillac Fleetwood   8 10.4  0         automatic\nValiant              6 18.1  0         automatic\nDatsun 710           4 22.8  1            manual\nHornet Sportabout    8 18.7  0         automatic\nHonda Civic          4 30.4  1            manual\nMerc 450SL           8 17.3  0         automatic\n```\n\n\n:::\n:::\n\n\n## `ggplot2`\n\nAs a briefly introduction to ggplot2, it is maybe considered one of the best tools for data visualization.\n\nThe syntax is: first, the `ggplot()` functions receives the data. Going forward we must link the layers using '`+`'. Then we choose the geometry corresponding the graphic type. In geometry we pass `aes()` with the axis inside like `aes(x, y, fill)`, and the color, size points and other arguments.\n\nLet's try a scatterplot with mtcars dataset to view the relationship between 'miles per gallon' and 'horsepower':\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars) +\n    geom_point( aes( x = hp, y = mpg),\n                color = 'darkblue', size=4, alpha=0.5 ) +\n    ggtitle(\"Relationship between HP vs MPG\")\n```\n\n::: {.cell-output-display}\n![](11_transformations_tidyverse_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "11_transformations_tidyverse_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}